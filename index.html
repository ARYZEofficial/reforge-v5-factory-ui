<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARYZE Contracts V5 - Admin UI</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>
    <style>
        :root {
            --bg: #f1f5f9;
            --card: #ffffff;
            --border: #e2e8f0;
            --text: #0f172a;
            --muted: #64748b;
            --accent: #2563eb;
            --success: #16a34a;
            --danger: #dc2626;
            --orange: #ea580c;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, sans-serif; background: var(--bg); color: var(--text); font-size: 13px; }
        .header { background: var(--card); border-bottom: 1px solid var(--border); padding: 12px 16px; display: flex; align-items: center; gap: 16px; flex-wrap: wrap; }
        .header h1 { font-size: 15px; font-weight: 600; }
        .network-toggle { display: flex; border: 1px solid var(--border); border-radius: 6px; overflow: hidden; }
        .network-btn { padding: 6px 14px; border: none; background: var(--card); cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.15s; }
        .network-btn:not(:last-child) { border-right: 1px solid var(--border); }
        .network-btn.active { background: var(--accent); color: white; }
        .network-btn:hover:not(.active) { background: #f8fafc; }
        .wallet-section { display: flex; gap: 8px; align-items: center; margin-left: auto; }
        .btn { padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 500; transition: all 0.15s; }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: #1d4ed8; }
        .btn-orange { background: var(--orange); color: white; }
        .btn-orange:hover { background: #c2410c; }
        .status { padding: 4px 10px; border-radius: 12px; font-size: 11px; font-weight: 600; }
        .status.connected { background: #dcfce7; color: #166534; }
        .status.disconnected { background: #fee2e2; color: #991b1b; }
        .main { padding: 16px; }
        .tabs { display: flex; gap: 4px; margin-bottom: 16px; }
        .tab { padding: 8px 16px; border: 1px solid var(--border); border-radius: 6px 6px 0 0; background: var(--card); cursor: pointer; font-weight: 500; }
        .tab.active { background: var(--accent); color: white; border-color: var(--accent); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .contract-section { background: var(--card); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 16px; }
        .contract-header { padding: 12px 16px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 12px; }
        .contract-header input { flex: 1; padding: 8px 10px; border: 1px solid var(--border); border-radius: 4px; font-family: monospace; font-size: 12px; }
        .methods-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; padding: 16px; }
        .method-card { border: 1px solid var(--border); border-radius: 6px; padding: 12px; }
        .method-card.read { border-left: 3px solid var(--success); }
        .method-card.write { border-left: 3px solid var(--accent); }
        .method-name { font-weight: 600; font-size: 13px; margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
        .method-tag { font-size: 9px; padding: 2px 6px; border-radius: 3px; text-transform: uppercase; font-weight: 700; }
        .method-tag.read { background: #dcfce7; color: #166534; }
        .method-tag.write { background: #dbeafe; color: #1e40af; }
        .method-inputs { display: flex; flex-direction: column; gap: 6px; margin-bottom: 8px; }
        .method-input { display: flex; align-items: center; gap: 8px; }
        .method-input label { min-width: 100px; font-size: 11px; color: var(--muted); }
        .method-input input { flex: 1; padding: 6px 8px; border: 1px solid var(--border); border-radius: 4px; font-size: 12px; font-family: monospace; }
        .method-actions { display: flex; gap: 8px; align-items: center; }
        .method-result { flex: 1; padding: 6px 8px; background: #f8fafc; border-radius: 4px; font-family: monospace; font-size: 11px; word-break: break-all; min-height: 28px; }
        .method-result.error { background: #fee2e2; color: var(--danger); }
        .method-result.success { background: #dcfce7; color: var(--success); }
        .section-title { padding: 12px 16px; background: #f8fafc; font-weight: 600; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--muted); border-bottom: 1px solid var(--border); }
        .loading { opacity: 0.6; pointer-events: none; }
        .setup-wizard { background: var(--card); border: 1px solid var(--border); border-radius: 8px; margin-bottom: 16px; }
        .setup-header { padding: 12px 16px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
        .setup-header h2 { font-size: 14px; font-weight: 600; }
        .setup-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; background: var(--border); }
        .setup-section { background: var(--card); padding: 16px; }
        .setup-section h3 { font-size: 12px; font-weight: 600; margin-bottom: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }
        .setup-step { display: flex; align-items: flex-start; gap: 10px; padding: 8px 0; border-bottom: 1px solid var(--border); }
        .setup-step:last-child { border-bottom: none; }
        .step-icon { width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 11px; flex-shrink: 0; margin-top: 2px; }
        .step-icon.pending { background: #f1f5f9; color: var(--muted); }
        .step-icon.success { background: #dcfce7; color: var(--success); }
        .step-icon.error { background: #fee2e2; color: var(--danger); }
        .step-icon.loading { background: #dbeafe; color: var(--accent); animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .step-content { flex: 1; }
        .step-title { font-size: 12px; font-weight: 500; margin-bottom: 2px; }
        .step-desc { font-size: 11px; color: var(--muted); }
        .step-value { font-size: 10px; font-family: monospace; color: var(--accent); margin-top: 4px; word-break: break-all; }
        .step-action { margin-top: 6px; }
        .step-action .btn { padding: 4px 8px; font-size: 10px; }
        .token-list { max-height: 200px; overflow-y: auto; }
        .token-item { display: flex; align-items: center; gap: 8px; padding: 8px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.15s; }
        .token-item:hover { background: #f8fafc; }
        .token-item:last-child { border-bottom: none; }
        .token-info { flex: 1; min-width: 0; }
        .token-name { font-size: 12px; font-weight: 600; }
        .token-addr { font-size: 10px; font-family: monospace; color: var(--muted); overflow: hidden; text-overflow: ellipsis; }
        .token-badges { display: flex; gap: 4px; flex-shrink: 0; }
        .token-badge { font-size: 9px; padding: 2px 5px; border-radius: 3px; font-weight: 600; }
        .token-badge.ok { background: #dcfce7; color: #166534; }
        .token-badge.no { background: #fee2e2; color: #991b1b; }
        .bridge-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; padding: 16px; }
        .bridge-card { border: 1px solid var(--border); border-radius: 8px; padding: 16px; }
        .bridge-card h3 { font-size: 14px; font-weight: 600; margin-bottom: 16px; display: flex; align-items: center; gap: 8px; }
        .bridge-card h3 .badge { font-size: 10px; padding: 3px 8px; border-radius: 4px; font-weight: 600; }
        .bridge-card h3 .badge.green { background: #dcfce7; color: #166534; }
        .bridge-card h3 .badge.blue { background: #dbeafe; color: #1e40af; }
        .bridge-form { display: flex; flex-direction: column; gap: 12px; }
        .bridge-field label { display: block; font-size: 11px; font-weight: 500; color: var(--muted); margin-bottom: 4px; }
        .bridge-field input, .bridge-field select { width: 100%; padding: 10px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px; }
        .bridge-field input:focus, .bridge-field select:focus { outline: none; border-color: var(--accent); }
        .bridge-field select { background: var(--card); cursor: pointer; }
        .bridge-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .bridge-btn { width: 100%; padding: 12px; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.15s; }
        .bridge-btn.primary { background: var(--accent); color: white; }
        .bridge-btn.primary:hover { background: #1d4ed8; }
        .bridge-btn.secondary { background: var(--orange); color: white; }
        .bridge-btn.secondary:hover { background: #c2410c; }
        .bridge-result { margin-top: 12px; padding: 12px; border-radius: 6px; font-size: 12px; font-family: monospace; word-break: break-all; }
        .bridge-result.success { background: #dcfce7; color: #166534; }
        .bridge-result.error { background: #fee2e2; color: #991b1b; }
        .bridge-result.info { background: #f8fafc; color: var(--text); }
        .bridge-info { font-size: 11px; color: var(--muted); padding: 8px; background: #f8fafc; border-radius: 4px; margin-top: 8px; }
        .fee-breakdown { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 12px; }
        .fee-item { background: #f8fafc; padding: 10px; border-radius: 6px; text-align: center; }
        .fee-item.total { background: #dbeafe; }
        .fee-label { font-size: 10px; color: var(--muted); text-transform: uppercase; margin-bottom: 4px; }
        .fee-value { font-size: 14px; font-weight: 600; font-family: monospace; }
        .gas-presets { display: flex; gap: 6px; margin-top: 6px; }
        .gas-preset { padding: 4px 8px; font-size: 10px; border: 1px solid var(--border); border-radius: 4px; cursor: pointer; background: var(--card); }
        .gas-preset:hover { background: #f8fafc; }
        .gas-preset.active { background: var(--accent); color: white; border-color: var(--accent); }
        .gas-help { font-size: 10px; color: var(--muted); margin-top: 4px; }
        .protocol-fee-display { background: #fef3c7; padding: 8px 12px; border-radius: 6px; margin-bottom: 12px; font-size: 12px; display: flex; justify-content: space-between; align-items: center; }
        .protocol-fee-display .label { color: #92400e; font-weight: 500; }
        .protocol-fee-display .value { font-family: monospace; font-weight: 600; }
    </style>
</head>
<body>

<div class="header">
    <h1>ARYZE Contracts V5</h1>
    <div class="network-toggle">
        <button class="network-btn" data-network="amoy">Amoy</button>
        <button class="network-btn active" data-network="bnb">BNB Testnet</button>
    </div>
    <div class="wallet-section">
        <span class="status disconnected" id="walletStatus">Disconnected</span>
        <button class="btn btn-primary" id="connectBtn">Connect Wallet</button>
    </div>
</div>

<div class="main">
    <div class="setup-wizard">
        <div class="setup-header">
            <h2>Setup Checklist</h2>
            <button class="btn btn-orange" onclick="runSetupChecks()">Refresh Status</button>
        </div>
        <div class="setup-grid">
            <div class="setup-section">
                <h3>1. Factory Setup</h3>
                <div class="setup-step" id="step-beacon">
                    <div class="step-icon pending">?</div>
                    <div class="step-content">
                        <div class="step-title">Beacon Initialized</div>
                        <div class="step-desc">ERC20 beacon must be deployed</div>
                        <div class="step-value" id="step-beacon-value"></div>
                    </div>
                </div>
                <div class="setup-step" id="step-router-set">
                    <div class="step-icon pending">?</div>
                    <div class="step-content">
                        <div class="step-title">Router Set on Factory</div>
                        <div class="step-desc">Factory.setRouter(routerAddress)</div>
                        <div class="step-value" id="step-router-set-value"></div>
                    </div>
                </div>
                <div class="setup-step" id="step-factory-paused">
                    <div class="step-icon pending">?</div>
                    <div class="step-content">
                        <div class="step-title">Factory Not Paused</div>
                        <div class="step-desc">Factory must be unpaused to deploy tokens</div>
                    </div>
                </div>
            </div>
            <div class="setup-section">
                <h3>2. Router Setup</h3>
                <div class="setup-step" id="step-factory-role">
                    <div class="step-icon pending">?</div>
                    <div class="step-content">
                        <div class="step-title">Factory has ERC20_FACTORY_ROLE</div>
                        <div class="step-desc">Router.grantRole(ERC20_FACTORY_ROLE, factory)</div>
                    </div>
                </div>
                <div class="setup-step" id="step-peer">
                    <div class="step-icon pending">?</div>
                    <div class="step-content">
                        <div class="step-title">Peer Router Configured</div>
                        <div class="step-desc" id="step-peer-desc">Router.setPeer(eid, peerAddress)</div>
                        <div class="step-value" id="step-peer-value"></div>
                    </div>
                </div>
                <div class="setup-step" id="step-lz-paused">
                    <div class="step-icon pending">?</div>
                    <div class="step-content">
                        <div class="step-title">LayerZero Not Paused</div>
                        <div class="step-desc">LZ bridge operations must be enabled</div>
                    </div>
                </div>
            </div>
            <div class="setup-section">
                <h3>3. Deployed Tokens <span id="token-count" style="font-weight:400;color:var(--muted)"></span></h3>
                <div class="token-list" id="token-list">
                    <div style="padding:12px;color:var(--muted);font-size:11px">Loading tokens...</div>
                </div>
                <div class="setup-step" style="margin-top:8px;border-top:1px solid var(--border);padding-top:8px">
                    <div class="step-icon" style="background:#dbeafe;color:var(--accent)">i</div>
                    <div class="step-content">
                        <div class="step-desc">Click token to load in ERC20 tab. Badges show: ROUTER = has ROUTER_ROLE, BRIDGE = in bridgeable whitelist</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tabs">
        <button class="tab active" data-tab="bridge">Bridge</button>
        <button class="tab" data-tab="factory">Factory</button>
        <button class="tab" data-tab="router">Router</button>
        <button class="tab" data-tab="erc20">ERC20 Token</button>
    </div>

    <div class="tab-content active" id="bridgeTab">
        <div class="contract-section">
            <div class="bridge-grid">
                <div class="bridge-card">
                    <h3>Permissionless Send <span class="badge green">No Signatures</span></h3>
                    <div class="bridge-form">
                        <div class="protocol-fee-display" id="sendProtocolFeeDisplay">
                            <span class="label">Protocol Fee:</span>
                            <span class="value" id="sendProtocolFeeValue">Loading...</span>
                        </div>
                        <div class="bridge-field">
                            <label>Token (must be whitelisted)</label>
                            <select id="sendToken">
                                <option value="">Select token...</option>
                            </select>
                        </div>
                        <div class="bridge-row">
                            <div class="bridge-field">
                                <label>Amount</label>
                                <input type="text" id="sendAmount" placeholder="1000000">
                            </div>
                            <div class="bridge-field">
                                <label>Destination Chain</label>
                                <select id="sendDstChain">
                                    <option value="40267">Polygon Amoy (40267)</option>
                                    <option value="40102">BNB Testnet (40102)</option>
                                </select>
                            </div>
                        </div>
                        <div class="bridge-row">
                            <div class="bridge-field">
                                <label>Recipient Address</label>
                                <input type="text" id="sendRecipient" placeholder="0x... (defaults to connected wallet)">
                            </div>
                            <div class="bridge-field">
                                <label>Gas Limit (for destination chain)</label>
                                <input type="text" id="sendGasLimit" value="150000" placeholder="150000" oninput="updateGasPresets('send')">
                                <div class="gas-presets">
                                    <button class="gas-preset" onclick="setGasLimit('send', 100000)">Min (100k)</button>
                                    <button class="gas-preset active" onclick="setGasLimit('send', 150000)">Standard (150k)</button>
                                    <button class="gas-preset" onclick="setGasLimit('send', 200000)">Safe (200k)</button>
                                </div>
                                <div class="gas-help">LayerZero charges for the full gas limit, not actual usage. Lower = cheaper.</div>
                            </div>
                        </div>
                        <button class="bridge-btn secondary" onclick="quoteSendFee()">Get Quote</button>
                        <div class="fee-breakdown" id="sendFeeBreakdown" style="display:none;">
                            <div class="fee-item">
                                <div class="fee-label">LayerZero Fee</div>
                                <div class="fee-value" id="sendLzFee">-</div>
                            </div>
                            <div class="fee-item">
                                <div class="fee-label">Protocol Fee</div>
                                <div class="fee-value" id="sendProtocolFee">-</div>
                            </div>
                            <div class="fee-item total">
                                <div class="fee-label">Total Cost</div>
                                <div class="fee-value" id="sendTotalFee">-</div>
                            </div>
                        </div>
                        <button class="bridge-btn primary" onclick="executeSend()">Send Tokens</button>
                        <div class="bridge-result info" id="sendResult">Select token and get a quote first</div>
                        <div class="bridge-info">
                            <b>Gas Limit:</b> Min 100,000. Typical send() uses ~80k-120k gas. Use 150k for safety.<br>
                            <b style="color:#dc2626">Testnet Note:</b> LZ testnet fees are artificially high (~2+ native tokens).
                            On mainnet, the same transaction costs ~$0.01-0.10. The fee is mostly a fixed base fee, not gas-dependent.
                        </div>
                    </div>
                </div>
                <div class="bridge-card">
                    <h3>Furnace (with Signatures) <span class="badge blue">Validator Signed</span></h3>
                    <div class="bridge-form">
                        <div class="bridge-field">
                            <label>Source Token</label>
                            <select id="furnaceToken">
                                <option value="">Select token...</option>
                            </select>
                        </div>
                        <div class="bridge-row">
                            <div class="bridge-field">
                                <label>Amount</label>
                                <input type="text" id="furnaceAmount" placeholder="1000000">
                            </div>
                            <div class="bridge-field">
                                <label>Destination Chain</label>
                                <select id="furnaceDstChain">
                                    <option value="40267">Polygon Amoy (40267)</option>
                                    <option value="40102">BNB Testnet (40102)</option>
                                </select>
                            </div>
                        </div>
                        <div class="bridge-field">
                            <label>Destination Token (same address for CREATE2)</label>
                            <input type="text" id="furnaceDstToken" placeholder="0x... (auto-filled from source)">
                        </div>
                        <div class="bridge-row">
                            <div class="bridge-field">
                                <label>Protocol Fee (wei) - set by validators</label>
                                <input type="text" id="furnaceFee" value="0" placeholder="0">
                            </div>
                            <div class="bridge-field">
                                <label>Gas Limit for LZ (destination)</label>
                                <input type="text" id="furnaceGasLimit" value="200000" placeholder="200000" oninput="updateGasPresets('furnace')">
                                <div class="gas-presets">
                                    <button class="gas-preset" onclick="setGasLimit('furnace', 150000)">Low (150k)</button>
                                    <button class="gas-preset active" onclick="setGasLimit('furnace', 200000)">Standard (200k)</button>
                                    <button class="gas-preset" onclick="setGasLimit('furnace', 300000)">High (300k)</button>
                                </div>
                            </div>
                        </div>
                        <button class="bridge-btn secondary" onclick="quoteFurnaceFee()">Get LZ Fee Quote</button>
                        <div class="fee-breakdown" id="furnaceFeeBreakdown" style="display:none;">
                            <div class="fee-item total" style="grid-column: span 3;">
                                <div class="fee-label">LayerZero Fee (user pays this)</div>
                                <div class="fee-value" id="furnaceLzFee">-</div>
                            </div>
                        </div>
                        <button class="bridge-btn secondary" onclick="generateFurnaceSignature()">1. Generate Permit + Validator Signature</button>
                        <button class="bridge-btn primary" onclick="executeFurnace()">2. Execute Furnace</button>
                        <div class="bridge-result info" id="furnaceResult">Get quote, generate signature, then execute</div>
                        <div class="bridge-info">
                            Furnace requires validator signatures. Connected wallet signs as both user and validator for testing.<br>
                            <b style="color:#dc2626">Testnet Note:</b> LZ testnet fees are ~2+ native tokens (mainnet: ~$0.01-0.10).
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tab-content" id="factoryTab">
        <div class="contract-section">
            <div class="contract-header">
                <span style="font-weight:500">Factory Address:</span>
                <input type="text" id="factoryAddress" value="0x53A72a66b2f9EC70E0EcbeA0663dceED6F0De82D">
                <button class="btn btn-primary" onclick="loadContract('factory')">Load</button>
            </div>
            <div class="section-title">Read Methods</div>
            <div class="methods-grid" id="factoryReadMethods"></div>
            <div class="section-title">Write Methods</div>
            <div class="methods-grid" id="factoryWriteMethods"></div>
        </div>
    </div>

    <div class="tab-content" id="routerTab">
        <div class="contract-section">
            <div class="contract-header">
                <span style="font-weight:500">Router Address:</span>
                <input type="text" id="routerAddress" value="0xFFa6B4F011ABF8cda18adA5449f438896e9C6eA3">
                <button class="btn btn-primary" onclick="loadContract('router')">Load</button>
            </div>
            <div class="section-title">Read Methods</div>
            <div class="methods-grid" id="routerReadMethods"></div>
            <div class="section-title">Write Methods</div>
            <div class="methods-grid" id="routerWriteMethods"></div>
        </div>
    </div>

    <div class="tab-content" id="erc20Tab">
        <div class="contract-section">
            <div class="contract-header">
                <span style="font-weight:500">Token:</span>
                <span id="erc20Name" style="font-weight:600;color:var(--accent)">Select from list above</span>
                <input type="text" id="erc20Address" placeholder="Or enter address manually" style="flex:0.5">
                <button class="btn btn-primary" onclick="loadContract('erc20')">Load</button>
            </div>
            <div class="section-title">Read Methods</div>
            <div class="methods-grid" id="erc20ReadMethods"></div>
            <div class="section-title">Write Methods</div>
            <div class="methods-grid" id="erc20WriteMethods"></div>
        </div>
    </div>
</div>

<script>
const NETWORKS = {
    amoy: {
        name: 'Polygon Amoy',
        chainId: 80002,
        rpc: 'https://polygon-amoy-bor-rpc.publicnode.com',
        explorer: 'https://amoy.polygonscan.com',
        lzEid: 40267,
        peerNetwork: 'bnb'
    },
    bnb: {
        name: 'BNB Testnet',
        chainId: 97,
        rpc: 'https://bsc-testnet-rpc.publicnode.com',
        explorer: 'https://testnet.bscscan.com',
        lzEid: 40102,
        peerNetwork: 'amoy'
    }
};

const DEFAULT_FACTORY = '0x53A72a66b2f9EC70E0EcbeA0663dceED6F0De82D';
const DEFAULT_ROUTER = '0xFFa6B4F011ABF8cda18adA5449f438896e9C6eA3';

let currentNetwork = 'bnb';
let provider = null;
let signer = null;
let contracts = {};
let abis = {};

async function loadAbis() {
    const names = ['factory', 'router', 'erc20'];
    for (const name of names) {
        const response = await fetch(`abi/${name}.json`);
        abis[name] = await response.json();
    }
}

function getProvider() {
    return new ethers.JsonRpcProvider(NETWORKS[currentNetwork].rpc);
}

// LayerZero message status tracking
async function trackLzMessage(txHash, resultEl) {
    const apiBase = 'https://scan-testnet.layerzero-api.com/v1';
    const scanUrl = `https://testnet.layerzeroscan.com/tx/${txHash}`;

    const statusEmoji = {
        'INFLIGHT': 'âœˆï¸',
        'CONFIRMING': 'â³',
        'DELIVERED': 'âœ…',
        'FAILED': 'âŒ',
        'BLOCKED': 'ðŸš«',
        'PAYLOAD_STORED': 'ðŸ“¦'
    };

    let attempts = 0;
    const maxAttempts = 60; // 5 minutes max (every 5 seconds)

    const poll = async () => {
        attempts++;
        try {
            const response = await fetch(`${apiBase}/messages/tx/${txHash}`);
            const data = await response.json();

            if (data.data && data.data.length > 0) {
                const msg = data.data[0];
                const status = msg.status?.name || msg.status || 'UNKNOWN';
                const emoji = statusEmoji[status] || 'ðŸ”„';

                if (status === 'DELIVERED') {
                    resultEl.className = 'bridge-result success';
                    resultEl.innerHTML = `${emoji} <b>Delivered!</b> Tokens received on destination chain.<br>
                        <a href="${scanUrl}" target="_blank" style="color:inherit">View on LayerZero Scan â†’</a>`;
                    return; // Stop polling
                } else if (status === 'FAILED' || status === 'BLOCKED') {
                    resultEl.className = 'bridge-result error';
                    resultEl.innerHTML = `${emoji} <b>${status}</b> - Message failed.<br>
                        <a href="${scanUrl}" target="_blank" style="color:inherit">View details â†’</a>`;
                    return; // Stop polling
                } else {
                    resultEl.innerHTML = `${emoji} <b>${status}</b> - Cross-chain message in progress...<br>
                        <small style="opacity:0.7">Polling ${attempts}/${maxAttempts}</small><br>
                        <a href="${scanUrl}" target="_blank" style="color:inherit">Track on LayerZero Scan â†’</a>`;
                }
            } else {
                resultEl.innerHTML = `ðŸ”„ Waiting for LayerZero to pick up message...<br>
                    <small style="opacity:0.7">Polling ${attempts}/${maxAttempts}</small><br>
                    <a href="${scanUrl}" target="_blank" style="color:inherit">Track on LayerZero Scan â†’</a>`;
            }

            if (attempts < maxAttempts) {
                setTimeout(poll, 5000); // Poll every 5 seconds
            } else {
                resultEl.innerHTML = `â±ï¸ Tracking timeout. Check status manually:<br>
                    <a href="${scanUrl}" target="_blank" style="color:inherit">View on LayerZero Scan â†’</a>`;
            }
        } catch (e) {
            console.error('LZ tracking error:', e);
            if (attempts < maxAttempts) {
                setTimeout(poll, 5000);
            }
        }
    };

    // Start polling after a short delay to let LZ index the tx
    setTimeout(poll, 3000);
}

async function connectWallet() {
    if (!window.ethereum) {
        alert('MetaMask not found');
        return;
    }

    const network = NETWORKS[currentNetwork];
    try {
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: '0x' + network.chainId.toString(16) }]
        });
    } catch (e) {
        if (e.code === 4902) {
            await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                    chainId: '0x' + network.chainId.toString(16),
                    chainName: network.name,
                    rpcUrls: [network.rpc],
                    blockExplorerUrls: [network.explorer]
                }]
            });
        }
    }

    provider = new ethers.BrowserProvider(window.ethereum);
    signer = await provider.getSigner();

    const address = await signer.getAddress();
    document.getElementById('walletStatus').textContent = address.slice(0, 6) + '...' + address.slice(-4);
    document.getElementById('walletStatus').className = 'status connected';
}

async function switchNetwork(network) {
    const wasConnected = signer !== null;
    currentNetwork = network;
    document.querySelectorAll('.network-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.network === network);
    });
    provider = null;
    signer = null;
    contracts = {};

    if (wasConnected && window.ethereum) {
        await connectWallet();
    } else {
        document.getElementById('walletStatus').textContent = 'Disconnected';
        document.getElementById('walletStatus').className = 'status disconnected';
    }

    updateDstChainSelectors();

    if (Object.keys(abis).length > 0) {
        runSetupChecks();
        populateSendTokenDropdown();
        loadProtocolFee();
    }
}

function updateDstChainSelectors() {
    const peerNetwork = NETWORKS[currentNetwork].peerNetwork;
    const peerEid = NETWORKS[peerNetwork].lzEid;
    const peerName = NETWORKS[peerNetwork].name;

    ['sendDstChain', 'furnaceDstChain'].forEach(id => {
        const select = document.getElementById(id);
        select.innerHTML = `<option value="${peerEid}">${peerName} (${peerEid})</option>`;
    });
}

function parseAbiItem(item) {
    if (item.type !== 'function') return null;

    return {
        name: item.name,
        inputs: (item.inputs || []).map(inp => ({
            type: inp.type,
            name: inp.name || inp.type
        })),
        outputs: item.outputs || [],
        isView: item.stateMutability === 'view' || item.stateMutability === 'pure',
        isPayable: item.stateMutability === 'payable'
    };
}

function getPlaceholder(type, name) {
    const n = name.toLowerCase();
    if (type === 'address') return '0x...';
    if (type === 'bytes32') return '0x...';
    if (type === 'bytes') return '0x...';
    if (type === 'bool') return 'true / false';
    if (type === 'string') return n.includes('name') ? 'Token Name' : n.includes('symbol') ? 'TKN' : 'text';
    if (type.startsWith('uint')) {
        if (n.includes('offset')) return '0';
        if (n.includes('limit')) return '10';
        if (n.includes('decimal')) return '6';
        if (n.includes('amount') || n.includes('value')) return '1000000';
        if (n.includes('eid')) return '40267 (Amoy) / 40102 (BNB)';
        if (n.includes('version')) return '1';
        if (n.includes('slug')) return '1';
        return '0';
    }
    return type;
}

function createMethodCard(contractType, method) {
    const card = document.createElement('div');
    card.className = `method-card ${method.isView ? 'read' : 'write'}`;

    const inputsHtml = method.inputs.map((inp, i) => `
        <div class="method-input">
            <label>${inp.name} (${inp.type})</label>
            <input type="text" id="${contractType}_${method.name}_${i}" placeholder="${getPlaceholder(inp.type, inp.name)}">
        </div>
    `).join('');

    card.innerHTML = `
        <div class="method-name">
            ${method.name}
            <span class="method-tag ${method.isView ? 'read' : 'write'}">${method.isView ? 'read' : 'write'}</span>
        </div>
        ${inputsHtml ? `<div class="method-inputs">${inputsHtml}</div>` : ''}
        <div class="method-actions">
            <div class="method-result" id="${contractType}_${method.name}_result"></div>
            <button class="btn ${method.isView ? 'btn-orange' : 'btn-primary'}" onclick="callMethod('${contractType}', '${method.name}', ${method.isView})">${method.isView ? 'Read' : 'Write'}</button>
        </div>
    `;

    return card;
}

function renderMethods(contractType) {
    const abi = abis[contractType];
    const readContainer = document.getElementById(`${contractType}ReadMethods`);
    const writeContainer = document.getElementById(`${contractType}WriteMethods`);

    readContainer.innerHTML = '';
    writeContainer.innerHTML = '';

    const methods = abi.map(parseAbiItem).filter(Boolean).sort((a, b) => a.name.localeCompare(b.name));

    for (const method of methods) {
        const card = createMethodCard(contractType, method);
        if (method.isView) {
            readContainer.appendChild(card);
        } else {
            writeContainer.appendChild(card);
        }
    }
}

async function loadContract(contractType) {
    const addressInput = document.getElementById(`${contractType}Address`);
    const address = addressInput.value.trim();

    if (!ethers.isAddress(address)) {
        alert('Invalid address');
        return;
    }

    const p = signer || getProvider();
    contracts[contractType] = new ethers.Contract(address, abis[contractType], p);
    renderMethods(contractType);
}

async function callMethod(contractType, methodName, isView) {
    const resultEl = document.getElementById(`${contractType}_${methodName}_result`);
    resultEl.className = 'method-result';
    resultEl.textContent = 'Loading...';

    try {
        const contract = contracts[contractType];
        if (!contract) {
            throw new Error('Contract not loaded');
        }

        const abi = abis[contractType];
        const abiItem = abi.find(item => item.type === 'function' && item.name === methodName);
        const method = parseAbiItem(abiItem);

        const args = method.inputs.map((inp, i) => {
            const val = document.getElementById(`${contractType}_${methodName}_${i}`).value;
            if (inp.type.startsWith('uint') || inp.type.startsWith('int')) {
                return val;
            }
            if (inp.type === 'bool') {
                return val.toLowerCase() === 'true';
            }
            return val;
        });

        let result;
        if (isView) {
            result = await contract[methodName](...args);
        } else {
            if (!signer) {
                throw new Error('Connect wallet first');
            }
            const contractWithSigner = contract.connect(signer);
            const tx = await contractWithSigner[methodName](...args);
            resultEl.textContent = `Tx: ${tx.hash}`;
            await tx.wait();
            result = 'Transaction confirmed';
        }

        resultEl.className = 'method-result success';
        resultEl.textContent = formatResult(result);
    } catch (e) {
        resultEl.className = 'method-result error';
        resultEl.textContent = e.reason || e.message || String(e);
    }
}

function formatResult(result) {
    if (result === null || result === undefined) return 'null';
    if (typeof result === 'bigint') return result.toString();
    if (Array.isArray(result)) return result.map(formatResult).join(', ');
    if (typeof result === 'object') {
        const entries = Object.entries(result).filter(([k]) => isNaN(k));
        if (entries.length > 0) {
            return entries.map(([k, v]) => `${k}: ${formatResult(v)}`).join(', ');
        }
        return JSON.stringify(result);
    }
    return String(result);
}

document.querySelectorAll('.network-btn').forEach(btn => {
    btn.addEventListener('click', () => switchNetwork(btn.dataset.network));
});

document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}Tab`).classList.add('active');
    });
});

document.getElementById('connectBtn').addEventListener('click', connectWallet);

function updateStepStatus(stepId, status, value = '') {
    const step = document.getElementById(stepId);
    const icon = step.querySelector('.step-icon');
    const valueEl = document.getElementById(`${stepId}-value`);

    icon.className = `step-icon ${status}`;
    if (status === 'success') icon.textContent = 'âœ“';
    else if (status === 'error') icon.textContent = 'âœ—';
    else if (status === 'loading') icon.textContent = '...';
    else icon.textContent = '?';

    if (valueEl && value) valueEl.textContent = value;
}

async function runSetupChecks() {
    const p = getProvider();
    const factoryAddr = document.getElementById('factoryAddress').value;
    const routerAddr = document.getElementById('routerAddress').value;

    const factory = new ethers.Contract(factoryAddr, abis.factory, p);
    const router = new ethers.Contract(routerAddr, abis.router, p);

    const steps = ['step-beacon', 'step-router-set', 'step-factory-paused', 'step-factory-role', 'step-peer', 'step-lz-paused'];
    steps.forEach(s => updateStepStatus(s, 'loading'));
    document.getElementById('token-list').innerHTML = '<div style="padding:12px;color:var(--muted);font-size:11px">Loading tokens...</div>';

    try {
        const isBeaconInit = await factory.isBeaconInitialized();
        updateStepStatus('step-beacon', isBeaconInit ? 'success' : 'error');
        if (isBeaconInit) {
            const beacon = await factory.erc20Beacon();
            document.getElementById('step-beacon-value').textContent = beacon;
        }
    } catch (e) { updateStepStatus('step-beacon', 'error'); }

    try {
        const routerOnFactory = await factory.router();
        const isSet = routerOnFactory !== ethers.ZeroAddress;
        updateStepStatus('step-router-set', isSet ? 'success' : 'error');
        document.getElementById('step-router-set-value').textContent = isSet ? routerOnFactory : 'Not set';
    } catch (e) { updateStepStatus('step-router-set', 'error'); }

    try {
        const isPaused = await factory.paused();
        updateStepStatus('step-factory-paused', isPaused ? 'error' : 'success');
    } catch (e) { updateStepStatus('step-factory-paused', 'error'); }

    try {
        const factoryRole = await router.ERC20_FACTORY_ROLE();
        const hasRole = await router.hasRole(factoryRole, factoryAddr);
        updateStepStatus('step-factory-role', hasRole ? 'success' : 'error');
    } catch (e) { updateStepStatus('step-factory-role', 'error'); }

    try {
        const peerNetwork = NETWORKS[currentNetwork].peerNetwork;
        const peerEid = NETWORKS[peerNetwork].lzEid;
        const peer = await router.peers(peerEid);
        const isSet = peer !== ethers.ZeroHash;
        updateStepStatus('step-peer', isSet ? 'success' : 'error');
        document.getElementById('step-peer-desc').textContent = `Peer for ${NETWORKS[peerNetwork].name} (EID: ${peerEid})`;
        document.getElementById('step-peer-value').textContent = isSet ? peer : 'Not set';
    } catch (e) { updateStepStatus('step-peer', 'error'); }

    try {
        const lzPaused = await router.lzPaused();
        updateStepStatus('step-lz-paused', lzPaused ? 'error' : 'success');
    } catch (e) { updateStepStatus('step-lz-paused', 'error'); }

    await loadTokenList(factory, router, routerAddr, p);
}

async function loadTokenList(factory, router, routerAddr, provider) {
    const listEl = document.getElementById('token-list');
    const countEl = document.getElementById('token-count');

    try {
        const tokenCount = await factory.getDeployedTokensCount();
        const count = Number(tokenCount);
        countEl.textContent = `(${count})`;

        if (count === 0) {
            listEl.innerHTML = '<div style="padding:12px;color:var(--muted);font-size:11px">No tokens deployed yet</div>';
            return;
        }

        const tokens = await factory.getDeployedTokens(0, Math.min(count, 20));
        const routerRole = ethers.keccak256(ethers.toUtf8Bytes("ROUTER_ROLE"));

        listEl.innerHTML = '';
        for (const tokenAddr of tokens) {
            const token = new ethers.Contract(tokenAddr, abis.erc20, provider);

            let symbol = '???', name = '???';
            let hasRouterRole = false, isBridgeable = false;

            try { symbol = await token.symbol(); } catch {}
            try { name = await token.name(); } catch {}
            try { hasRouterRole = await token.hasRole(routerRole, routerAddr); } catch {}
            try { isBridgeable = await router.isBridgeableToken(tokenAddr); } catch {}

            const item = document.createElement('div');
            item.className = 'token-item';
            item.onclick = () => selectToken(tokenAddr, symbol, name);
            item.innerHTML = `
                <div class="token-info">
                    <div class="token-name">${symbol} - ${name}</div>
                    <div class="token-addr">${tokenAddr}</div>
                </div>
                <div class="token-badges">
                    <span class="token-badge ${hasRouterRole ? 'ok' : 'no'}">ROUTER</span>
                    <span class="token-badge ${isBridgeable ? 'ok' : 'no'}">BRIDGE</span>
                </div>
            `;
            listEl.appendChild(item);
        }
    } catch (e) {
        listEl.innerHTML = `<div style="padding:12px;color:var(--danger);font-size:11px">Error: ${e.message}</div>`;
    }
}

async function selectToken(address, symbol, name) {
    document.getElementById('erc20Address').value = address;
    document.getElementById('erc20Name').textContent = `${symbol} - ${name}`;
    await loadContract('erc20');
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.querySelector('[data-tab="erc20"]').classList.add('active');
    document.getElementById('erc20Tab').classList.add('active');
}

let furnaceSignatureData = null;

function setGasLimit(type, value) {
    const input = document.getElementById(`${type}GasLimit`);
    input.value = value;
    updateGasPresets(type);
}

function updateGasPresets(type) {
    const input = document.getElementById(`${type}GasLimit`);
    const value = parseInt(input.value) || 0;
    const presets = input.parentElement.querySelectorAll('.gas-preset');

    presets.forEach(preset => {
        const presetValue = parseInt(preset.onclick.toString().match(/\d+/)?.[0]) || 0;
        preset.classList.toggle('active', Math.abs(value - presetValue) < 1000);
    });
}

async function loadProtocolFee() {
    try {
        const p = getProvider();
        const routerAddr = document.getElementById('routerAddress').value;
        const router = new ethers.Contract(routerAddr, abis.router, p);

        const protocolFee = await router.getSendProtocolFee();
        const feeDisplay = document.getElementById('sendProtocolFeeValue');

        if (protocolFee === 0n) {
            feeDisplay.textContent = 'None (0)';
            document.getElementById('sendProtocolFeeDisplay').style.background = '#dcfce7';
            document.getElementById('sendProtocolFeeDisplay').querySelector('.label').style.color = '#166534';
        } else {
            feeDisplay.textContent = ethers.formatEther(protocolFee) + ' native';
        }
    } catch (e) {
        document.getElementById('sendProtocolFeeValue').textContent = 'Error loading';
    }
}

async function populateSendTokenDropdown() {
    const sendSelect = document.getElementById('sendToken');
    const furnaceSelect = document.getElementById('furnaceToken');
    sendSelect.innerHTML = '<option value="">Select token...</option>';
    furnaceSelect.innerHTML = '<option value="">Select token...</option>';

    try {
        const p = getProvider();
        const factoryAddr = document.getElementById('factoryAddress').value;
        const routerAddr = document.getElementById('routerAddress').value;
        const factory = new ethers.Contract(factoryAddr, abis.factory, p);
        const router = new ethers.Contract(routerAddr, abis.router, p);

        const tokenCount = await factory.getDeployedTokensCount();
        if (tokenCount === 0n) return;

        const tokens = await factory.getDeployedTokens(0, Math.min(Number(tokenCount), 20));

        for (const tokenAddr of tokens) {
            const isBridgeable = await router.isBridgeableToken(tokenAddr);
            if (isBridgeable) {
                const token = new ethers.Contract(tokenAddr, abis.erc20, p);
                let symbol = '???';
                try { symbol = await token.symbol(); } catch {}

                const optionText = `${symbol} (${tokenAddr.slice(0, 8)}...)`;

                const sendOption = document.createElement('option');
                sendOption.value = tokenAddr;
                sendOption.textContent = optionText;
                sendSelect.appendChild(sendOption);

                const furnaceOption = document.createElement('option');
                furnaceOption.value = tokenAddr;
                furnaceOption.textContent = optionText;
                furnaceSelect.appendChild(furnaceOption);
            }
        }
    } catch (e) {
        console.error('Error populating token dropdown:', e);
    }
}

async function quoteSendFee() {
    const resultEl = document.getElementById('sendResult');
    const breakdownEl = document.getElementById('sendFeeBreakdown');
    resultEl.className = 'bridge-result info';
    resultEl.textContent = 'Getting quote...';
    breakdownEl.style.display = 'none';

    try {
        const token = document.getElementById('sendToken').value;
        const amount = document.getElementById('sendAmount').value;
        const dstEid = parseInt(document.getElementById('sendDstChain').value);
        const gasLimitInput = document.getElementById('sendGasLimit').value || '150000';
        const gasLimit = parseInt(gasLimitInput);
        let recipient = document.getElementById('sendRecipient').value.trim();

        if (!token) throw new Error('Select a token');
        if (!amount) throw new Error('Enter amount');
        if (isNaN(gasLimit) || gasLimit < 100000) {
            throw new Error('Gas limit must be at least 100,000');
        }

        if (!recipient) {
            if (!signer) throw new Error('Connect wallet or enter recipient');
            recipient = await signer.getAddress();
        }

        const p = getProvider();
        const routerAddr = document.getElementById('routerAddress').value;
        const router = new ethers.Contract(routerAddr, abis.router, p);

        const payload = ethers.AbiCoder.defaultAbiCoder().encode(
            ['uint256', 'address'],
            [ethers.parseUnits(amount, 6), recipient]
        );

        const [lzFee, protocolFee] = await router.quoteSend(token, recipient, payload, dstEid, gasLimit);
        const totalFee = lzFee + protocolFee;

        // Update fee breakdown display
        document.getElementById('sendLzFee').textContent = ethers.formatEther(lzFee).slice(0, 10);
        document.getElementById('sendProtocolFee').textContent = ethers.formatEther(protocolFee).slice(0, 10);
        document.getElementById('sendTotalFee').textContent = ethers.formatEther(totalFee).slice(0, 10);
        breakdownEl.style.display = 'grid';

        resultEl.className = 'bridge-result success';
        resultEl.innerHTML = `Quote ready! Gas limit: ${parseInt(gasLimit).toLocaleString()} | Total: <b>${ethers.formatEther(totalFee).slice(0, 10)} native</b>`;
    } catch (e) {
        resultEl.className = 'bridge-result error';
        resultEl.textContent = e.reason || e.message || String(e);
        breakdownEl.style.display = 'none';
    }
}

async function executeSend() {
    const resultEl = document.getElementById('sendResult');
    resultEl.className = 'bridge-result info';
    resultEl.textContent = 'Preparing transaction...';

    try {
        if (!signer) throw new Error('Connect wallet first');

        const token = document.getElementById('sendToken').value;
        const amount = document.getElementById('sendAmount').value;
        const dstEid = parseInt(document.getElementById('sendDstChain').value);
        const gasLimitInput = document.getElementById('sendGasLimit').value || '150000';
        const gasLimit = parseInt(gasLimitInput);
        let recipient = document.getElementById('sendRecipient').value.trim();

        if (!token) throw new Error('Select a token');
        if (!amount) throw new Error('Enter amount');
        if (isNaN(gasLimit) || gasLimit < 100000) throw new Error('Gas limit must be at least 100,000');
        if (!recipient) recipient = await signer.getAddress();

        const routerAddr = document.getElementById('routerAddress').value;
        const router = new ethers.Contract(routerAddr, abis.router, signer);
        const tokenContract = new ethers.Contract(token, abis.erc20, signer);

        const amountWei = ethers.parseUnits(amount, 6);
        const payload = ethers.AbiCoder.defaultAbiCoder().encode(
            ['uint256', 'address'],
            [amountWei, recipient]
        );

        const [lzFee, protocolFee] = await router.quoteSend(token, recipient, payload, dstEid, gasLimit);
        const totalFee = lzFee + protocolFee;

        resultEl.textContent = 'Checking allowance...';
        const userAddr = await signer.getAddress();
        const allowance = await tokenContract.allowance(userAddr, routerAddr);

        if (allowance < amountWei) {
            resultEl.textContent = 'Approving tokens...';
            const approveTx = await tokenContract.approve(routerAddr, amountWei);
            await approveTx.wait();
        }

        resultEl.textContent = 'Sending transaction...';
        const sendParams = { token, dstEid, recipient, gasLimit, payload };
        const tx = await router.send(sendParams, { value: totalFee });

        resultEl.textContent = `Tx submitted: ${tx.hash}`;
        await tx.wait();

        resultEl.className = 'bridge-result success';
        resultEl.innerHTML = `âœ… Source tx confirmed! Tracking cross-chain delivery...<br>
            <a href="https://testnet.layerzeroscan.com/tx/${tx.hash}" target="_blank" style="color:inherit">Track on LayerZero Scan â†’</a>`;

        // Start tracking LayerZero message status
        trackLzMessage(tx.hash, resultEl);
    } catch (e) {
        resultEl.className = 'bridge-result error';
        resultEl.textContent = e.reason || e.message || String(e);
    }
}

function buildLzOptions(gasLimit) {
    const TYPE_3 = 3;
    const WORKER_ID = 1;
    const OPTION_TYPE_LZ_RECEIVE = 1;
    const gas = BigInt(gasLimit);

    // Option format per LayerZero OptionsBuilder: [workerId][length][optionType][data]
    // length = 17 (1 byte optionType + 16 bytes for uint128 gas)
    const option = ethers.solidityPacked(
        ['uint8', 'uint16', 'uint8', 'uint128'],
        [WORKER_ID, 17, OPTION_TYPE_LZ_RECEIVE, gas]
    );

    return ethers.solidityPacked(['uint16', 'bytes'], [TYPE_3, option]);
}

async function quoteFurnaceFee() {
    const resultEl = document.getElementById('furnaceResult');
    const breakdownEl = document.getElementById('furnaceFeeBreakdown');
    resultEl.className = 'bridge-result info';
    resultEl.textContent = 'Getting LZ fee quote...';
    breakdownEl.style.display = 'none';

    try {
        const srcToken = document.getElementById('furnaceToken').value.trim();
        const amount = document.getElementById('furnaceAmount').value;
        const dstEid = parseInt(document.getElementById('furnaceDstChain').value);
        let dstToken = document.getElementById('furnaceDstToken').value.trim();
        const gasLimit = document.getElementById('furnaceGasLimit').value || '200000';

        if (!srcToken) throw new Error('Enter source token address');
        if (!amount) throw new Error('Enter amount');
        if (!dstToken) dstToken = srcToken;

        let userAddr;
        if (signer) {
            userAddr = await signer.getAddress();
        } else {
            userAddr = '0x0000000000000000000000000000000000000001'; // placeholder for quote
        }

        const amountWei = ethers.parseUnits(amount, 6);
        const fxRate = 1000000n;

        const payload = ethers.AbiCoder.defaultAbiCoder().encode(
            ['uint256', 'address', 'uint256'],
            [amountWei, userAddr, fxRate]
        );

        const lzOptions = buildLzOptions(gasLimit);

        const p = getProvider();
        const routerAddr = document.getElementById('routerAddress').value;
        const router = new ethers.Contract(routerAddr, abis.router, p);

        const nativeFee = await router.quoteFurnace(dstEid, userAddr, dstToken, payload, lzOptions);

        document.getElementById('furnaceLzFee').textContent = ethers.formatEther(nativeFee).slice(0, 10) + ' native';
        breakdownEl.style.display = 'grid';

        resultEl.className = 'bridge-result success';
        resultEl.innerHTML = `LZ Fee: <b>${ethers.formatEther(nativeFee).slice(0, 10)} native</b> (gas limit: ${parseInt(gasLimit).toLocaleString()})`;
    } catch (e) {
        resultEl.className = 'bridge-result error';
        resultEl.textContent = e.reason || e.message || String(e);
        breakdownEl.style.display = 'none';
    }
}

async function generateFurnaceSignature() {
    const resultEl = document.getElementById('furnaceResult');
    resultEl.className = 'bridge-result info';
    resultEl.textContent = 'Generating signature...';

    try {
        if (!signer) throw new Error('Connect wallet first');

        const userAddr = await signer.getAddress();
        const routerAddr = document.getElementById('routerAddress').value;

        // Check if connected wallet is a registered signer
        const p = getProvider();
        const routerRead = new ethers.Contract(routerAddr, abis.router, p);
        const registeredSigners = await routerRead.signers();
        const requiredSigs = await routerRead.requiredSignatures();

        console.log('Registered signers:', registeredSigners);
        console.log('Required signatures:', requiredSigs.toString());
        console.log('Connected wallet:', userAddr);

        const isSigner = registeredSigners.some(s => s.toLowerCase() === userAddr.toLowerCase());
        if (!isSigner) {
            throw new Error(`Connected wallet (${userAddr}) is NOT a registered signer. Registered signers: ${registeredSigners.join(', ')}`);
        }

        const srcToken = document.getElementById('furnaceToken').value.trim();
        const amount = document.getElementById('furnaceAmount').value;
        const dstEid = parseInt(document.getElementById('furnaceDstChain').value);
        let dstToken = document.getElementById('furnaceDstToken').value.trim();
        const fee = document.getElementById('furnaceFee').value || '0';
        const gasLimit = document.getElementById('furnaceGasLimit').value || '500000';

        if (!srcToken) throw new Error('Enter source token address');
        if (!amount) throw new Error('Enter amount');
        if (!dstToken) dstToken = srcToken;
        const amountWei = ethers.parseUnits(amount, 6);

        // V5 furnace payload only contains amount (no recipient, no fxRate)
        const payload = ethers.AbiCoder.defaultAbiCoder().encode(['uint256'], [amountWei]);

        const lzOptions = buildLzOptions(gasLimit);
        const deadline = Math.floor(Date.now() / 1000) + 3600; // Use Number for deadline
        const chainId = NETWORKS[currentNetwork].chainId;

        // === STEP 1: Create ERC20 Permit Signature ===
        // The user (token owner) signs to allow router to spend their tokens
        resultEl.textContent = 'Step 1/2: Sign permit to allow router...';

        const tokenContract = new ethers.Contract(srcToken, abis.erc20, p);
        const tokenName = await tokenContract.name();
        const nonce = await tokenContract.nonces(userAddr);

        const permitDomain = {
            name: tokenName,
            version: '1',
            chainId: chainId,
            verifyingContract: srcToken
        };

        const permitTypes = {
            Permit: [
                { name: 'owner', type: 'address' },
                { name: 'spender', type: 'address' },
                { name: 'value', type: 'uint256' },
                { name: 'nonce', type: 'uint256' },
                { name: 'deadline', type: 'uint256' }
            ]
        };

        const permitValue = {
            owner: userAddr,
            spender: routerAddr,
            value: amountWei,
            nonce: nonce,
            deadline: deadline
        };

        console.log('=== Permit Signature ===');
        console.log('Permit Domain:', permitDomain);
        console.log('Permit Value:', permitValue);

        const permitSignature = await signer.signTypedData(permitDomain, permitTypes, permitValue);
        console.log('Permit Signature:', permitSignature);

        // === STEP 2: Create Validator Signature ===
        // The validator signs over the furnace params INCLUDING the permit signature
        resultEl.textContent = 'Step 2/2: Sign validator approval...';

        const routerDomain = {
            name: 'ARYZE LZ Router',
            version: '1',
            chainId: chainId,
            verifyingContract: routerAddr
        };

        // EIP-712 type must match contract's FURNACE_PERMIT_TYPEHASH exactly
        const furnaceTypes = {
            FurnacePermitV5: [
                { name: 'deadline', type: 'uint256' },
                { name: 'account', type: 'address' },
                { name: 'fee', type: 'uint256' },
                { name: 'srcContract', type: 'address' },
                { name: 'dstEid', type: 'uint32' },
                { name: 'dstContract', type: 'address' },
                { name: 'contractType', type: 'uint256' },
                { name: 'payload', type: 'bytes' },
                { name: 'lzOptions', type: 'bytes' },
                { name: 'permitSignature', type: 'bytes' },
                { name: 'comment', type: 'string' }
            ]
        };

        const feeBigInt = BigInt(fee);

        const furnaceValue = {
            deadline: deadline,
            account: userAddr,
            fee: feeBigInt,
            srcContract: srcToken,
            dstEid: dstEid,
            dstContract: dstToken,
            contractType: 0n,
            payload: payload,
            lzOptions: lzOptions,
            permitSignature: permitSignature, // Include the actual permit signature!
            comment: ''
        };

        console.log('=== Validator Signature ===');
        console.log('Router Domain:', routerDomain);
        console.log('Furnace Value:', furnaceValue);

        const validatorSignature = await signer.signTypedData(routerDomain, furnaceTypes, furnaceValue);
        console.log('Validator Signature:', validatorSignature);

        // Build the furnace params for the contract call
        // signatures[0] = permit signature (for token.permit())
        // signatures[1] = validator signature (for furnace validation)
        furnaceSignatureData = {
            account: userAddr,
            dstEid: dstEid,
            srcContract: srcToken,
            dstContract: dstToken,
            fee: feeBigInt,
            contractType: 0n,
            payload: payload,
            lzOptions: lzOptions,
            comment: '',
            signatures: [
                { deadline: deadline, signature: permitSignature },
                { deadline: deadline, signature: validatorSignature }
            ]
        };

        console.log('FurnaceSignatureData:', furnaceSignatureData);

        resultEl.className = 'bridge-result success';
        resultEl.innerHTML = `Signatures generated!<br>Deadline: ${new Date(deadline * 1000).toLocaleString()}<br>Signer: ${userAddr}<br>Click "Execute Furnace" to proceed.`;
    } catch (e) {
        resultEl.className = 'bridge-result error';
        resultEl.textContent = e.reason || e.message || String(e);
    }
}

async function executeFurnace() {
    const resultEl = document.getElementById('furnaceResult');
    resultEl.className = 'bridge-result info';
    resultEl.textContent = 'Preparing furnace...';

    try {
        if (!signer) throw new Error('Connect wallet first');
        if (!furnaceSignatureData) throw new Error('Generate signature first');

        const routerAddr = document.getElementById('routerAddress').value;
        const router = new ethers.Contract(routerAddr, abis.router, signer);

        // No need to check allowance - the contract executes permit from signatures[0]
        resultEl.textContent = 'Getting LZ fee quote...';
        const nativeFee = await router.quoteFurnace(
            furnaceSignatureData.dstEid,
            furnaceSignatureData.account,
            furnaceSignatureData.dstContract,
            furnaceSignatureData.payload,
            furnaceSignatureData.lzOptions
        );

        // Total value = LZ fee + protocol fee
        const totalValue = nativeFee + furnaceSignatureData.fee;
        resultEl.textContent = `LZ Fee: ${ethers.formatEther(nativeFee)} - Sending transaction...`;

        const tx = await router.furnace(furnaceSignatureData, { value: totalValue });

        resultEl.textContent = `Tx submitted: ${tx.hash}`;
        await tx.wait();

        resultEl.className = 'bridge-result success';
        resultEl.innerHTML = `âœ… Furnace tx confirmed! Tracking cross-chain delivery...<br>
            <a href="https://testnet.layerzeroscan.com/tx/${tx.hash}" target="_blank" style="color:inherit">Track on LayerZero Scan â†’</a>`;
        furnaceSignatureData = null;

        // Start tracking LayerZero message status
        trackLzMessage(tx.hash, resultEl);
    } catch (e) {
        resultEl.className = 'bridge-result error';
        resultEl.textContent = e.reason || e.message || String(e);
    }
}

document.getElementById('sendToken').addEventListener('change', async (e) => {
    const furnaceTokenSelect = document.getElementById('furnaceToken');
    const furnaceDstTokenInput = document.getElementById('furnaceDstToken');
    if (e.target.value) {
        furnaceTokenSelect.value = e.target.value;
        furnaceDstTokenInput.value = e.target.value;
    }
});

document.getElementById('furnaceToken').addEventListener('change', async (e) => {
    const furnaceDstTokenInput = document.getElementById('furnaceDstToken');
    if (e.target.value) {
        furnaceDstTokenInput.value = e.target.value;
    }
});

loadAbis().then(async () => {
    ['factory', 'router', 'erc20'].forEach(renderMethods);
    loadContract('factory');
    loadContract('router');
    updateDstChainSelectors();
    runSetupChecks();
    await populateSendTokenDropdown();
    loadProtocolFee();

    // Auto-select first option in dropdowns
    selectFirstOptions();

    // Auto-connect wallet on page load
    if (window.ethereum) {
        try {
            await connectWallet();
        } catch (e) {
            console.log('Auto-connect failed:', e.message);
        }
    }
});

function selectFirstOptions() {
    // Select first option in send token dropdown
    const sendToken = document.getElementById('sendToken');
    if (sendToken && sendToken.options.length > 1) {
        sendToken.selectedIndex = 1;
        sendToken.dispatchEvent(new Event('change'));
    }

    // Select first option in furnace token dropdown
    const furnaceToken = document.getElementById('furnaceToken');
    if (furnaceToken && furnaceToken.options.length > 1) {
        furnaceToken.selectedIndex = 1;
        furnaceToken.dispatchEvent(new Event('change'));
    }
}
</script>

</body>
</html>
