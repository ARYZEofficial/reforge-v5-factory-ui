<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARYZE Factory V1 - Admin UI</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>
    <style>
        :root {
            --bg-page: #f1f5f9;
            --bg-card: #ffffff;
            --bg-input: #f8fafc;
            --border: #e2e8f0;
            --border-focus: #3b82f6;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --text-muted: #94a3b8;
            --accent: #2563eb;
            --accent-hover: #1d4ed8;
            --success: #16a34a;
            --warning: #ca8a04;
            --danger: #dc2626;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-page);
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.5;
        }

        .container { max-width: 100%; margin: 0; padding: 12px; }

        /* ========== HEADER ========== */
        .page-header {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px 14px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .page-header h1 { font-size: 16px; font-weight: 600; }
        .network-badge {
            background: #dbeafe;
            color: #1e40af;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        /* ========== CONNECTION PANEL ========== */
        .connection-panel {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }
        .connection-panel h3 {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }
        .connection-row {
            display: flex;
            gap: 8px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        .field { flex: 1; min-width: 150px; }
        .field label {
            display: block;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        .field input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            background: var(--bg-input);
            transition: border-color 0.15s;
        }
        .field input:focus {
            outline: none;
            border-color: var(--border-focus);
            background: #fff;
        }
        .connection-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .btn-connect {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s;
        }
        .btn-connect:hover { background: var(--accent-hover); }
        .btn-network {
            background: #fff;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            padding: 7px 12px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-network:hover { border-color: var(--text-secondary); }

        /* Status pill */
        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        .status-pill .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }
        .status-pill.connected { background: #dcfce7; color: #166534; }
        .status-pill.connected .dot { background: #22c55e; }
        .status-pill.disconnected { background: #fee2e2; color: #991b1b; }
        .status-pill.disconnected .dot { background: #ef4444; }

        /* ========== ROLES BAR ========== */
        .roles-bar {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 12px;
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }
        .roles-bar .label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-right: 6px;
        }
        .role-badge {
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
        }
        .role-badge.active { background: #dcfce7; color: #166534; }
        .role-badge.inactive { background: #f1f5f9; color: #94a3b8; }

        /* Beacon status */
        .beacon-status {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .beacon-status.not-initialized { border-left: 3px solid var(--warning); }
        .beacon-status.initialized { border-left: 3px solid var(--success); }
        .beacon-status .status-text { font-weight: 600; font-size: 12px; }
        .beacon-status .help-text { font-size: 11px; color: var(--text-secondary); }

        /* ========== TABS ========== */
        .tab-container {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            overflow: hidden;
        }
        .tab-nav {
            display: flex;
            background: #f8fafc;
            border-bottom: 1px solid var(--border);
            padding: 0;
            margin: 0;
        }
        .tab-btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            background: transparent;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
        }
        .tab-btn:hover {
            background: #f1f5f9;
            color: var(--text-primary);
        }
        .tab-btn.active {
            background: #fff;
            color: var(--accent);
            border-bottom-color: var(--accent);
        }
        .tab-content {
            padding: 12px;
        }
        .tab-panel { display: none; }
        .tab-panel.active { display: block; }

        /* Section header inside tab */
        .section-header {
            margin-bottom: 12px;
        }
        .section-header h2 {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }
        .section-header .description {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* ========== GRID ========== */
        .grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        /* ========== CARDS ========== */
        .card {
            background: #fff;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 14px;
        }
        /* Card title styling */
        .card > h2:first-child {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }
        .card.disabled { opacity: 0.5; pointer-events: none; }
        .card h3 {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin: 20px 0 10px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        .card h3:first-child { margin-top: 0; padding-top: 0; border-top: none; }

        /* ========== FORMS ========== */
        .form-group { margin-bottom: 10px; }
        .form-group label {
            display: block;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 12px;
            background: var(--bg-input);
            color: var(--text-primary);
            transition: border-color 0.15s;
        }
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--border-focus);
            background: #fff;
        }
        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group textarea {
            font-family: 'SF Mono', Monaco, monospace;
        }
        .form-group textarea { min-height: 80px; resize: vertical; }
        .form-group select { cursor: pointer; }

        /* ========== BUTTONS ========== */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 14px;
            border-radius: 4px;
            border: none;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            width: 100%;
            margin-top: 8px;
            position: relative;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.loading { color: transparent !important; pointer-events: none; }
        .btn.loading::after {
            content: '';
            position: absolute;
            width: 16px; height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .btn-primary { background: var(--accent); color: #fff; }
        .btn-primary:hover:not(:disabled) { background: var(--accent-hover); }

        .btn-success { background: var(--success); color: #fff; }
        .btn-success:hover:not(:disabled) { background: #15803d; }

        .btn-warning { background: var(--warning); color: #fff; }
        .btn-warning:hover:not(:disabled) { background: #a16207; }

        .btn-danger { background: var(--danger); color: #fff; }
        .btn-danger:hover:not(:disabled) { background: #b91c1c; }

        .btn-secondary {
            background: #fff;
            color: var(--text-secondary);
            border: 2px solid var(--border);
        }
        .btn-secondary:hover:not(:disabled) {
            background: #f8fafc;
            border-color: #cbd5e1;
        }

        /* Button row */
        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .btn-row .btn { flex: 1; margin-top: 0; }

        /* ========== RESULTS ========== */
        .result {
            margin-top: 14px;
            padding: 12px 14px;
            border-radius: 6px;
            background: #f8fafc;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            word-break: break-all;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid var(--border);
        }
        .result.success { background: #f0fdf4; border-color: #bbf7d0; color: #166534; }
        .result.error { background: #fef2f2; border-color: #fecaca; color: #991b1b; }

        /* ========== INFO TABLE ========== */
        .info-table { width: 100%; }
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #f1f5f9;
            font-size: 12px;
            gap: 8px;
        }
        .info-row:last-child { border-bottom: none; }
        .info-label { color: var(--text-secondary); white-space: nowrap; flex-shrink: 0; }
        .info-value {
            color: var(--text-primary);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            text-align: right;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 180px;
        }
        .info-value.address { cursor: pointer; }
        .info-value.address:hover { color: var(--accent); }

        /* ========== TOKEN LIST ========== */
        .token-list { max-height: 350px; overflow-y: auto; }
        .token-item {
            padding: 14px;
            background: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .token-item:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
        }
        .token-symbol { font-weight: 600; color: var(--text-primary); font-size: 14px; }
        .token-name { font-size: 12px; color: var(--text-secondary); }
        .token-address {
            font-size: 11px;
            color: var(--text-muted);
            font-family: monospace;
            margin-top: 6px;
        }
        .token-owner { font-size: 11px; color: var(--text-secondary); margin-top: 4px; }

        /* ========== BADGES ========== */
        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .badge-version { background: #dbeafe; color: #1e40af; }
        .badge-role { background: #dcfce7; color: #166534; }

        /* ========== HELPER TEXT ========== */
        .help-text {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 6px;
        }
        .info-box {
            padding: 12px 14px;
            border-radius: 6px;
            font-size: 12px;
            margin: 12px 0;
        }
        .info-box.warning { background: #fef3c7; color: #92400e; border: 1px solid #fde68a; }
        .info-box.success { background: #dcfce7; color: #166534; border: 1px solid #bbf7d0; }
        .info-box.info { background: #dbeafe; color: #1e40af; border: 1px solid #bfdbfe; }

        .hidden { display: none !important; }

        /* ========== MODAL ========== */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        .modal-content {
            background: #fff;
            border-radius: 12px;
            width: 90%;
            max-width: 480px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25);
        }
        .modal-header {
            padding: 18px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h3 { font-size: 16px; font-weight: 600; }
        .modal-close {
            width: 32px; height: 32px;
            border: none;
            background: #f1f5f9;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-close:hover { background: #e2e8f0; }
        .modal-body {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
            font-size: 13px;
        }
        .modal-body pre {
            background: #f8fafc;
            padding: 14px;
            border-radius: 6px;
            font-size: 12px;
            overflow-x: auto;
        }
        .modal-body.success { color: var(--success); }
        .modal-body.error { color: var(--danger); }
        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            text-align: right;
        }

        /* ========== RESPONSIVE ========== */
        @media (max-width: 1200px) {
            .grid { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 768px) {
            .container { padding: 8px; }
            .grid { grid-template-columns: 1fr; gap: 8px; }
            .connection-row { flex-direction: column; }
            .field { min-width: 100%; }
            .connection-actions { width: 100%; justify-content: stretch; }
            .connection-actions > * { flex: 1; }
            .tab-content { padding: 8px; }
            .card { padding: 10px; }
        }
    </style>
</head>
<body>
    <!-- Verification Modal -->
    <div id="verifyModal" class="modal-overlay hidden" onclick="if(event.target===this)this.classList.add('hidden')">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">Verification Result</h3>
                <button class="modal-close" onclick="document.getElementById('verifyModal').classList.add('hidden')" type="button">&times;</button>
            </div>
            <div id="modalBody" class="modal-body">Loading...</div>
            <div style="margin-top: 20px; text-align: right;">
                <button class="btn btn-primary" onclick="document.getElementById('verifyModal').classList.add('hidden')" type="button" style="width: auto; padding: 12px 32px;">Close</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Page Header -->
        <div class="page-header">
            <h1>ARYZE Factory</h1>
            <span class="network-badge">Polygon Amoy Testnet</span>
        </div>

        <!-- Wallet Connection Panel (Global) -->
        <div class="connection-panel">
            <h3>Wallet Connection</h3>
            <div class="connection-row">
                <div class="field">
                    <label>RPC URL (fallback if no wallet)</label>
                    <input type="text" id="rpcUrl" placeholder="RPC URL" value="https://polygon-amoy-bor-rpc.publicnode.com" />
                </div>
                <div class="connection-actions">
                    <button class="btn-connect" onclick="connectWallet()">Connect Wallet</button>
                    <button class="btn-network" onclick="switchToAmoy()">Switch to Amoy</button>
                    <span id="connectionStatus" class="status-pill disconnected"><span class="dot"></span>Disconnected</span>
                </div>
            </div>
        </div>

        <!-- Tab Navigation -->
        <div class="tab-container">
        <div class="tab-nav">
            <button class="tab-btn factory-tab active" onclick="switchTab('factory')">Factory</button>
            <button class="tab-btn router-tab" onclick="switchTab('router')">Router</button>
            <button class="tab-btn erc20-tab" onclick="switchTab('erc20')">Tokens</button>
        </div>
        <div class="tab-content">

        <!-- ==================== ERC20 TOKENS TAB ==================== -->
        <div id="erc20-tab" class="tab-panel">
            <div class="section-header">
                <h2>ERC20 Token Management</h2>
                <p class="description">Deploy, upgrade, and manage tokens</p>
            </div>

            <!-- Factory Connection Status for Tokens Tab (hidden by default, shown if connection fails) -->
            <div id="tokensFactoryNotice" class="info-box warning" style="margin-bottom: 12px; display: none;">
                <strong>Factory not connected.</strong> Connect wallet first or check if you're on Amoy network.
            </div>

        <div class="grid">
            <!-- Deploy ERC20 Token -->
            <div class="card" id="deployTokenCard">
                <h2>Deploy New ERC20 Token <span class="badge badge-role">DEPLOYER</span></h2>
                <div id="deployerLimitInfo" style="background: #f3f4f6; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-size: 0.85em;">
                    <span style="color: #666;">Your deployment limit:</span>
                    <span id="yourLimit" style="color: #d97706;">-</span> |
                    <span style="color: #666;">Deployed:</span>
                    <span id="yourDeployed" style="color: #16a34a;">-</span>
                </div>
                <div class="form-group">
                    <label>Token Name</label>
                    <input type="text" id="tokenName" placeholder="e.g., ARYZE Euro" />
                </div>
                <div class="form-group">
                    <label>Token Symbol</label>
                    <input type="text" id="tokenSymbol" placeholder="e.g., eEUR" />
                </div>
                <div class="form-group">
                    <label>Decimals</label>
                    <input type="number" id="tokenDecimals" value="6" min="0" max="18" />
                </div>
                <div class="success-box">
                    You (the deployer) will automatically become the token admin with all roles.
                </div>
                <div class="form-group">
                    <label>Slug (unique number for CREATE2)</label>
                    <input type="number" id="tokenSlug" value="1" min="0" />
                    <div class="help-text">Use same slug across chains for deterministic addresses</div>
                    <div class="warning-box" style="margin-top: 8px;">
                        <strong>CREATE2 Security:</strong> Deploy Factory on ALL target chains FIRST before deploying any tokens.
                    </div>
                </div>
                <button class="btn btn-success" onclick="deployToken()" id="deployTokenBtn">Deploy Token</button>
                <button class="btn btn-secondary" onclick="computeAddress()">Compute Address</button>
                <div id="deployResult" class="result hidden"></div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="btn btn-primary hidden" id="verifyDeployedBtn" onclick="verifyDeployedToken()" style="flex: 1;">Verify on Explorer</button>
                    <button class="btn btn-success hidden" id="configureDeployedBtn" onclick="configureLastDeployedToken()" style="flex: 1;">Configure for Bridge</button>
                </div>
                <div id="verifyResult" class="result hidden"></div>
            </div>

            <!-- Deployed Tokens List -->
            <div class="card">
                <h2>Deployed Tokens</h2>
                <div id="tokenList" class="token-list">
                    <p style="color: #666; text-align: center;">Connect to load tokens</p>
                </div>
                <button class="btn btn-secondary" onclick="loadTokens()">Refresh List</button>
            </div>

            <!-- Token Upgrade (Owner Only) -->
            <div class="card">
                <h2>Upgrade Token <span class="badge badge-role">TOKEN OWNER</span></h2>
                <div class="help-text" style="margin-bottom: 15px;">Only the token owner (set at deployment) can upgrade their token to a new version.</div>
                <div class="form-group">
                    <label>Token Address</label>
                    <input type="text" id="upgradeTokenAddr" placeholder="0x..." />
                </div>
                <div class="form-group">
                    <label>New Version</label>
                    <input type="number" id="upgradeVersion" value="2" min="1" />
                </div>
                <button class="btn btn-warning" onclick="upgradeToken(this)">Upgrade Token</button>
                <div id="upgradeResult" class="result hidden"></div>
            </div>

            <!-- Transfer Token Ownership -->
            <div class="card">
                <h2>Transfer Token Ownership <span class="badge badge-role">TOKEN OWNER</span></h2>
                <div class="form-group">
                    <label>Token Address</label>
                    <input type="text" id="transferTokenAddr" placeholder="0x..." />
                </div>
                <div class="form-group">
                    <label>New Owner Address</label>
                    <input type="text" id="newOwnerAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-warning" onclick="transferOwnership(this)">Transfer Ownership</button>
                <div id="transferResult" class="result hidden"></div>
            </div>
        </div>

        <!-- ==================== QUERY DATA SECTION ==================== -->
        <h2 style="color: #4f46e5; margin: 40px 0 20px; padding-bottom: 10px; border-bottom: 2px solid #e5e7eb;">Query Data</h2>
        <div class="grid">
            <!-- Lookup Token by Symbol -->
            <div class="card">
                <h2>Lookup Token by Symbol</h2>
                <div class="form-group">
                    <label>Token Symbol</label>
                    <input type="text" id="lookupSymbol" placeholder="e.g., eEUR" />
                </div>
                <button class="btn btn-primary" onclick="lookupBySymbol(this)">Search</button>
                <div id="lookupSymbolResult" class="result hidden"></div>
            </div>

            <!-- Token Info Lookup -->
            <div class="card">
                <h2>Token Info Lookup</h2>
                <div class="form-group">
                    <label>Token Address</label>
                    <input type="text" id="tokenInfoAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-primary" onclick="lookupTokenInfo(this)">Get Info</button>
                <div id="tokenInfoResult" class="result hidden"></div>
            </div>

            <!-- Tokens by Owner -->
            <div class="card">
                <h2>Tokens by Owner</h2>
                <div class="form-group">
                    <label>Owner Address</label>
                    <input type="text" id="ownerLookupAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-primary" onclick="lookupTokensByOwner(this)">Get Tokens</button>
                <div id="ownerTokensResult" class="result hidden" style="max-height: 200px;"></div>
            </div>

            <!-- Check Slug Usage -->
            <div class="card">
                <h2>Check Slug Usage</h2>
                <div class="form-group">
                    <label>Deployer Address</label>
                    <input type="text" id="slugDeployer" placeholder="0x... (leave empty for connected wallet)" />
                </div>
                <div class="form-group">
                    <label>Slug Number</label>
                    <input type="number" id="slugNumber" value="1" min="0" />
                </div>
                <button class="btn btn-primary" onclick="checkSlugUsage(this)">Check Slug</button>
                <div id="slugResult" class="result hidden"></div>
            </div>

            <!-- User Deployment Info -->
            <div class="card">
                <h2>User Deployment Info</h2>
                <div class="form-group">
                    <label>User Address</label>
                    <input type="text" id="userInfoAddr" placeholder="0x... (leave empty for connected wallet)" />
                </div>
                <button class="btn btn-primary" onclick="lookupUserInfo(this)">Get Info</button>
                <div id="userInfoResult" class="result hidden"></div>
            </div>

            <!-- Role Checker -->
            <div class="card">
                <h2>Check Role</h2>
                <div class="form-group">
                    <label>Role</label>
                    <select id="checkRoleSelect">
                        <option value="DEFAULT_ADMIN_ROLE">DEFAULT_ADMIN_ROLE</option>
                        <option value="DEPLOYER_ROLE">DEPLOYER_ROLE</option>
                        <option value="BEACON_UPGRADER_ROLE">BEACON_UPGRADER_ROLE</option>
                        <option value="UPGRADER_ROLE">UPGRADER_ROLE</option>
                        <option value="PAUSER_ROLE">PAUSER_ROLE</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Address</label>
                    <input type="text" id="checkRoleAddr" placeholder="0x... (leave empty for connected wallet)" />
                </div>
                <button class="btn btn-primary" onclick="checkRole(this)">Check Role</button>
                <div id="checkRoleResult" class="result hidden"></div>
            </div>
        </div>
        </div><!-- End ERC20 Tab -->

        <!-- ==================== FACTORY ADMIN TAB ==================== -->
        <div id="factory-tab" class="tab-panel active">
            <div class="section-header">
                <h2>Factory Administration</h2>
                <p class="description">Beacon, versions, roles, and deployment settings</p>
            </div>

            <!-- Factory Status -->
            <div class="connection-panel" style="margin-bottom: 12px;">
                <div class="connection-row">
                    <div class="field" style="flex: 2;">
                        <label>Factory Address (Amoy)</label>
                        <input type="text" id="factoryAddress" placeholder="0x..." value="0xDd7DB1dAC66AC3277c2140Fb132f0f68d3e08272" />
                    </div>
                    <div class="connection-actions">
                        <button class="btn-network" onclick="connectFactory()">Refresh</button>
                        <span id="factoryStatus" class="status-pill disconnected"><span class="dot"></span>Not Connected</span>
                    </div>
                </div>
            </div>

            <!-- Factory Roles Bar -->
            <div class="roles-bar" id="rolesBar" style="display: none;">
                <span class="label">Your Roles:</span>
                <span id="roleAdmin" class="role-badge inactive">ADMIN</span>
                <span id="roleDeployer" class="role-badge inactive">DEPLOYER</span>
                <span id="roleBeaconUpgrader" class="role-badge inactive">BEACON_UPGRADER</span>
                <span id="roleUpgrader" class="role-badge inactive">UPGRADER</span>
                <span id="rolePauser" class="role-badge inactive">PAUSER</span>
            </div>

            <!-- Beacon Status -->
            <div class="beacon-status not-initialized" id="beaconStatus" style="display: none;">
                <div>
                    <div class="status-text" id="beaconStatusText">Beacon not initialized</div>
                    <div class="help-text" id="beaconHelpText">Deploy beacon to enable token deployment</div>
                </div>
                <div class="status-icon" id="beaconStatusIcon">&#9888;</div>
            </div>

        <div class="grid">
            <!-- Factory Info -->
            <div class="card">
                <h2>Factory Information</h2>
                <div id="factoryInfo">
                    <div class="info-row"><span class="info-label">Factory Address</span><span class="info-value" id="infoFactoryAddr">-</span></div>
                    <div class="info-row"><span class="info-label">Beacon Initialized</span><span class="info-value" id="infoBeaconInit">-</span></div>
                    <div class="info-row"><span class="info-label">ERC20 Beacon</span><span class="info-value address" id="infoBeacon">-</span></div>
                    <div class="info-row"><span class="info-label">Default Implementation</span><span class="info-value address" id="infoImpl">-</span></div>
                    <div class="info-row"><span class="info-label">Latest Version</span><span class="info-value" id="infoLatestVer">-</span></div>
                    <div class="info-row"><span class="info-label">Default Version</span><span class="info-value" id="infoDefaultVer">-</span></div>
                    <div class="info-row"><span class="info-label">Router</span><span class="info-value address" id="infoRouter">-</span></div>
                    <div class="info-row"><span class="info-label">Deployed Tokens</span><span class="info-value" id="infoTokenCount">-</span></div>
                    <div class="info-row"><span class="info-label">Default Deploy Limit</span><span class="info-value" id="infoDefaultLimit">-</span></div>
                    <div class="info-row"><span class="info-label">Paused</span><span class="info-value" id="infoPaused">-</span></div>
                </div>
                <button class="btn btn-secondary" onclick="refreshInfo()">Refresh Info</button>
            </div>

            <!-- Beacon & Versions Overview -->
            <div class="card" id="beaconVersionsCard">
                <h2>Beacon & Versions</h2>
                <div id="versionsInfo" style="margin-bottom: 15px;">
                    <div class="info-row"><span class="info-label">VersionedBeacon</span><span class="info-value address" id="versionBeaconAddr">-</span></div>
                    <div class="info-row"><span class="info-label">Latest Version</span><span class="info-value" id="versionLatest">-</span></div>
                    <div class="info-row"><span class="info-label">Default Version</span><span class="info-value" id="versionDefault">-</span></div>
                </div>
                <h3>All Implementations</h3>
                <div id="versionsList" class="token-list" style="max-height: 200px; margin-bottom: 15px;">
                    <p style="color: #666; text-align: center;">Loading versions...</p>
                </div>
                <button class="btn btn-secondary" onclick="loadVersions()">Refresh Versions</button>
            </div>

            <!-- Version Management -->
            <div class="card" id="versionCard">
                <h2>Add Implementation <span class="badge badge-role">BEACON_UPGRADER</span></h2>
                <div class="help-text" style="margin-bottom: 15px;">
                    Add a new ERC20 implementation version to the beacon.
                </div>

                <h3>Add Existing Contract</h3>
                <div class="form-group">
                    <label>Implementation Address</label>
                    <input type="text" id="newImpl" placeholder="0x..." />
                </div>
                <button class="btn btn-warning" onclick="addImplementation(this)">Add Implementation</button>

                <h3 style="margin-top: 20px;">Deploy & Add New</h3>
                <div class="form-group">
                    <label>Implementation Bytecode</label>
                    <textarea id="newImplBytecode" placeholder="0x608060..."></textarea>
                </div>
                <button class="btn btn-success" onclick="deployAndAddImplementation(this)">Deploy & Add</button>

                <h3 style="margin-top: 20px;">Change Default Version</h3>
                <div class="form-group">
                    <label>Version Number</label>
                    <input type="number" id="defaultVersion" value="1" min="1" />
                </div>
                <button class="btn btn-warning" onclick="setDefaultVersion(this)">Set Default Version</button>
                <div id="versionResult" class="result hidden"></div>
            </div>

            <!-- Deployment Limits -->
            <div class="card">
                <h2>Deployment Limits <span class="badge badge-role">ADMIN</span></h2>
                <h3>Set User Limit</h3>
                <div class="form-group">
                    <label>User Address</label>
                    <input type="text" id="limitUserAddr" placeholder="0x..." />
                </div>
                <div class="form-group">
                    <label>New Limit (0 = use default)</label>
                    <input type="number" id="limitValue" value="5" min="0" />
                </div>
                <button class="btn btn-warning" onclick="setUserLimit(this)">Set User Limit</button>

                <h3>Set Default Limit</h3>
                <div class="form-group">
                    <label>New Default Limit</label>
                    <input type="number" id="defaultLimitValue" value="3" min="1" />
                </div>
                <button class="btn btn-warning" onclick="setDefaultLimit(this)">Set Default Limit</button>
                <div id="limitResult" class="result hidden"></div>
            </div>

            <!-- Router Management (Factory's V3 Router) -->
            <div class="card">
                <h2>Factory Router (V3) <span class="badge badge-role">ADMIN</span></h2>
                <div class="help-text" style="margin-bottom: 15px;">V3 Router is granted ROUTER_ROLE on new tokens automatically.</div>
                <div class="form-group">
                    <label>New Router Address</label>
                    <input type="text" id="newRouter" placeholder="0x..." />
                </div>
                <button class="btn btn-warning" onclick="setRouter(this)">Set Router</button>
                <div id="routerResult" class="result hidden"></div>
            </div>

            <!-- Role Management -->
            <div class="card">
                <h2>Role Management <span class="badge badge-role">ADMIN</span></h2>
                <h3>Grant Role</h3>
                <div class="form-group">
                    <label>Role</label>
                    <select id="grantRoleSelect">
                        <option value="DEPLOYER_ROLE">DEPLOYER_ROLE</option>
                        <option value="BEACON_UPGRADER_ROLE">BEACON_UPGRADER_ROLE</option>
                        <option value="UPGRADER_ROLE">UPGRADER_ROLE</option>
                        <option value="PAUSER_ROLE">PAUSER_ROLE</option>
                        <option value="DEFAULT_ADMIN_ROLE">DEFAULT_ADMIN_ROLE</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Address</label>
                    <input type="text" id="grantRoleAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-warning" onclick="grantRole(this)">Grant Role</button>

                <h3>Revoke Role</h3>
                <div class="form-group">
                    <label>Role</label>
                    <select id="revokeRoleSelect">
                        <option value="DEPLOYER_ROLE">DEPLOYER_ROLE</option>
                        <option value="BEACON_UPGRADER_ROLE">BEACON_UPGRADER_ROLE</option>
                        <option value="UPGRADER_ROLE">UPGRADER_ROLE</option>
                        <option value="PAUSER_ROLE">PAUSER_ROLE</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Address</label>
                    <input type="text" id="revokeRoleAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-danger" onclick="revokeRole(this)">Revoke Role</button>
                <div id="roleResult" class="result hidden"></div>
            </div>

            <!-- Pause Controls -->
            <div class="card">
                <h2>Pause Controls <span class="badge badge-role">PAUSER</span></h2>
                <p style="color: #666; margin-bottom: 15px; font-size: 0.9em;">
                    Pause/unpause token deployments.
                </p>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-danger" style="flex: 1;" onclick="pauseFactory(this)">Pause</button>
                    <button class="btn btn-success" style="flex: 1;" onclick="unpauseFactory(this)">Unpause</button>
                </div>
                <div id="pauseResult" class="result hidden"></div>
            </div>
        </div>
        </div><!-- End Factory Tab -->

        <!-- ==================== ROUTER V5 TAB ==================== -->
        <div id="router-tab" class="tab-panel">
            <div class="section-header">
                <h2>Router V5 Configuration</h2>
                <p class="description">LayerZero bridge integration and token whitelist</p>
            </div>
        <div class="grid">
            <!-- Router V5 Connection -->
            <div class="card" id="routerV5Card">
                <h2>Connect Router V5 <span class="badge badge-version">LayerZero</span></h2>
                <div class="form-group">
                    <label>Router V5 Address</label>
                    <input type="text" id="routerV5Address" placeholder="0x... (ReforgeRouterV5 address)" value="0xFFa6B4F011ABF8cda18adA5449f438896e9C6eA3" />
                    <div class="help-text">ReforgeRouterV5 with LayerZero integration</div>
                </div>
                <button class="btn btn-primary" onclick="connectRouterV5()">Connect Router V5</button>
                <div id="routerV5Status" style="background: #f3f4f6; padding: 10px; border-radius: 6px; margin-top: 12px; font-size: 0.85em;">
                    <span style="color: #666;">Router Status:</span>
                    <span id="routerV5StatusText" style="color: #9ca3af;">Not connected</span>
                </div>
            </div>

            <!-- Router V5 Info -->
            <div class="card">
                <h2>Router V5 Information</h2>
                <div id="routerV5Info">
                    <div class="info-row"><span class="info-label">Router Address</span><span class="info-value address" id="infoRouterV5Addr">-</span></div>
                    <div class="info-row"><span class="info-label">LZ Paused</span><span class="info-value" id="infoRouterPaused">-</span></div>
                    <div class="info-row"><span class="info-label">Fee Treasury</span><span class="info-value address" id="infoRouterTreasury">-</span></div>
                    <div class="info-row"><span class="info-label">Required Signatures</span><span class="info-value" id="infoRouterSigs">-</span></div>
                    <div class="info-row"><span class="info-label">Your Role</span><span class="info-value" id="infoRouterYourRole">-</span></div>
                </div>
                <button class="btn btn-secondary" onclick="refreshRouterV5Info()">Refresh Router Info</button>
            </div>

            <!-- Configure Token for Bridge (One-Click) -->
            <div class="card">
                <h2>Configure Token for Bridge <span class="badge badge-role">ONE-CLICK</span></h2>
                <div class="info-box warning">
                    After deploying a token, you must:<br>
                    1. Grant ROUTER_ROLE on the token to the router<br>
                    2. Add token to router's bridgeable whitelist<br><br>
                    <strong>This button does both steps automatically.</strong>
                </div>
                <div class="form-group">
                    <label>Token Address</label>
                    <input type="text" id="configureTokenAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-success" onclick="configureTokenForBridge(this)">Configure for Bridge</button>
                <div id="configureResult" class="result hidden"></div>
            </div>

            <!-- Grant ROUTER_ROLE -->
            <div class="card">
                <h2>Grant ROUTER_ROLE <span class="badge badge-role">TOKEN ADMIN</span></h2>
                <div class="help-text" style="margin-bottom: 12px;">
                    Grants the router permission to mint/burn tokens on behalf of bridge operations.
                </div>
                <div class="form-group">
                    <label>Token Address</label>
                    <input type="text" id="grantRouterRoleTokenAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-primary" onclick="grantRouterRole(this)">Grant ROUTER_ROLE</button>
                <div id="grantRouterRoleResult" class="result hidden"></div>
            </div>

            <!-- Add to Whitelist -->
            <div class="card">
                <h2>Add to Bridgeable Whitelist <span class="badge badge-role">ROUTER ADMIN</span></h2>
                <div class="help-text" style="margin-bottom: 12px;">
                    Adds a token to the router's list of tokens that can be bridged cross-chain.
                </div>
                <div class="form-group">
                    <label>Token Address</label>
                    <input type="text" id="addWhitelistTokenAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-warning" onclick="addToBridgeable(this)">Add to Whitelist</button>
                <div id="addWhitelistResult" class="result hidden"></div>
            </div>

            <!-- Check Token Status -->
            <div class="card">
                <h2>Check Token Bridge Status</h2>
                <div class="help-text" style="margin-bottom: 12px;">
                    Check if a token has ROUTER_ROLE granted and is in the bridgeable whitelist.
                </div>
                <div class="form-group">
                    <label>Token Address</label>
                    <input type="text" id="checkStatusTokenAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-secondary" onclick="checkTokenBridgeStatus(this)">Check Status</button>
                <div id="checkStatusResult" class="result hidden"></div>
            </div>

            <!-- Remove from Whitelist -->
            <div class="card">
                <h2>Remove from Whitelist <span class="badge badge-role">ROUTER ADMIN</span></h2>
                <div class="help-text" style="margin-bottom: 12px;">
                    Removes a token from the bridgeable whitelist. The token will no longer be bridgeable.
                </div>
                <div class="form-group">
                    <label>Token Address</label>
                    <input type="text" id="removeWhitelistTokenAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-danger" onclick="removeFromBridgeable(this)">Remove from Whitelist</button>
                <div id="removeWhitelistResult" class="result hidden"></div>
            </div>

            <!-- Set Fee Treasury -->
            <div class="card">
                <h2>Set Fee Treasury <span class="badge badge-role">ADMIN</span></h2>
                <div class="help-text" style="margin-bottom: 12px;">
                    Set the address that receives bridge fees.
                </div>
                <div class="form-group">
                    <label>Treasury Address</label>
                    <input type="text" id="setTreasuryAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-warning" onclick="setFeeTreasury(this)">Set Treasury</button>
                <div id="setTreasuryResult" class="result hidden"></div>
            </div>

            <!-- Add Signer -->
            <div class="card">
                <h2>Add Signer <span class="badge badge-role">ADMIN</span></h2>
                <div class="help-text" style="margin-bottom: 12px;">
                    Add a signer for furnace operations.
                </div>
                <div class="form-group">
                    <label>Signer Address</label>
                    <input type="text" id="addSignerAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-success" onclick="addSigner(this)">Add Signer</button>
                <div id="addSignerResult" class="result hidden"></div>
            </div>

            <!-- Remove Signer -->
            <div class="card">
                <h2>Remove Signer <span class="badge badge-role">ADMIN</span></h2>
                <div class="help-text" style="margin-bottom: 12px;">
                    Remove a signer from furnace operations.
                </div>
                <div class="form-group">
                    <label>Signer Address</label>
                    <input type="text" id="removeSignerAddr" placeholder="0x..." />
                </div>
                <button class="btn btn-danger" onclick="removeSigner(this)">Remove Signer</button>
                <div id="removeSignerResult" class="result hidden"></div>
            </div>

            <!-- Set Required Signatures -->
            <div class="card">
                <h2>Set Required Signatures <span class="badge badge-role">ADMIN</span></h2>
                <div class="help-text" style="margin-bottom: 12px;">
                    Set the number of signatures required for furnace operations.
                </div>
                <div class="form-group">
                    <label>Required Signatures</label>
                    <input type="number" id="requiredSigsInput" value="1" min="1" />
                </div>
                <button class="btn btn-warning" onclick="setRequiredSignatures(this)">Set Required</button>
                <div id="requiredSigsResult" class="result hidden"></div>
            </div>

            <!-- Grant ERC20_FACTORY_ROLE -->
            <div class="card">
                <h2>Grant Factory Role <span class="badge badge-role">ADMIN</span></h2>
                <div class="help-text" style="margin-bottom: 12px;">
                    Grant ERC20_FACTORY_ROLE to a factory contract, allowing it to add tokens to whitelist.
                </div>
                <div class="form-group">
                    <label>Factory Address</label>
                    <input type="text" id="grantFactoryRoleAddr" placeholder="0x..." value="0xDd7DB1dAC66AC3277c2140Fb132f0f68d3e08272" />
                </div>
                <button class="btn btn-success" onclick="grantFactoryRole(this)">Grant Factory Role</button>
                <div id="grantFactoryRoleResult" class="result hidden"></div>
            </div>
        </div>
        </div><!-- End Router Tab -->
        </div><!-- End Tab Content -->
        </div><!-- End Tab Container -->
    </div>

    <script>
        // Tab switching function
        function switchTab(tabName) {
            // Hide all tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            // Deactivate all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // Show selected tab panel
            document.getElementById(tabName + '-tab').classList.add('active');
            // Activate selected tab button
            document.querySelector('.' + tabName + '-tab').classList.add('active');
        }

        // Factory ABI - Updated to match FactoryV1.sol
        const FACTORY_ABI = [
            // View functions
            "function erc20Beacon() view returns (address)",
            "function erc20Implementation() view returns (address)",
            "function router() view returns (address)",
            "function getLatestVersion() view returns (uint256)",
            "function getDefaultVersion() view returns (uint256)",
            "function getDeployedTokensCount() view returns (uint256)",
            "function getDeployedTokens(uint256 offset, uint256 limit) view returns (address[])",
            "function getTokenBySymbol(string symbol) view returns (address)",
            "function getTokenVersion(address token) view returns (uint256)",
            "function getTokenImplementation(address token) view returns (address)",
            "function getImplementationAtVersion(uint256 version) view returns (address)",
            "function isSlugUsed(address deployer, uint256 slug) view returns (bool)",
            "function computeERC20Address(string name, string symbol, uint8 decimals, address deployer, uint256 slug) view returns (address)",
            "function paused() view returns (bool)",
            "function tokenOwner(address token) view returns (address)",
            "function getTokensByOwner(address owner) view returns (address[])",
            "function getUserDeploymentLimit(address user) view returns (uint256)",
            "function getUserDeployedCount(address user) view returns (uint256)",
            "function defaultDeploymentLimit() view returns (uint256)",
            "function isBeaconInitialized() view returns (bool)",
            // Role constants
            "function DEPLOYER_ROLE() view returns (bytes32)",
            "function BEACON_UPGRADER_ROLE() view returns (bytes32)",
            "function UPGRADER_ROLE() view returns (bytes32)",
            "function PAUSER_ROLE() view returns (bytes32)",
            "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
            // AccessControl functions
            "function hasRole(bytes32 role, address account) view returns (bool)",
            "function grantRole(bytes32 role, address account)",
            "function revokeRole(bytes32 role, address account)",
            // Write functions
            "function deployBeacon(bytes implementationBytecode)",
            "function deployERC20Token(string name, string symbol, uint8 decimals, uint256 slug) returns (address)",
            "function upgradeToken(address token, uint256 version)",
            "function transferTokenOwnership(address token, address newOwner)",
            "function setRouter(address newRouter)",
            "function addImplementationVersion(address newImpl) returns (uint256)",
            "function setDefaultVersion(uint256 version)",
            "function setUserDeploymentLimit(address user, uint256 limit)",
            "function setDefaultDeploymentLimit(uint256 limit)",
            "function pause()",
            "function unpause()",
            // Events
            "event ERC20BeaconCreated(address indexed beacon, address indexed implementation)",
            "event ERC20TokenDeployed(address indexed tokenAddress, string name, string symbol, uint8 decimals, address indexed owner, address indexed deployer)",
            "event TokenUpgraded(address indexed token, uint256 oldVersion, uint256 newVersion, address indexed upgradedBy)",
            "event TokenOwnershipTransferred(address indexed token, address indexed previousOwner, address indexed newOwner)",
            "event ImplementationVersionAdded(uint256 indexed version, address indexed implementation, address indexed addedBy)",
            "event DefaultVersionChanged(uint256 oldVersion, uint256 newVersion, address indexed changedBy)",
            "event RouterChanged(address oldRouter, address newRouter, address indexed changedBy)"
        ];

        const TOKEN_ABI = [
            "function name() view returns (string)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)",
            "function totalSupply() view returns (uint256)",
            "function paused() view returns (bool)",
            // Role management
            "function ROUTER_ROLE() view returns (bytes32)",
            "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
            "function hasRole(bytes32 role, address account) view returns (bool)",
            "function grantRole(bytes32 role, address account)",
            "function revokeRole(bytes32 role, address account)"
        ];

        // Router V5 ABI - ReforgeRouterV5 with LayerZero
        const ROUTER_V5_ABI = [
            // View functions
            "function lzPaused() view returns (bool)",
            "function feeTreasury() view returns (address)",
            "function signers() view returns (address[])",
            "function requiredSignatures() view returns (uint256)",
            "function isBridgeableToken(address token) view returns (bool)",
            "function isPeer(uint32 eid, bytes32 peer) view returns (bool)",
            "function peers(uint32 eid) view returns (bytes32)",
            "function SEND_GAS_LIMIT() view returns (uint128)",
            "function oAppVersion() view returns (uint64, uint64)",
            // Role constants
            "function DEFAULT_ADMIN_ROLE() view returns (bytes32)",
            "function UPGRADER_ROLE() view returns (bytes32)",
            "function PAUSER_ROLE() view returns (bytes32)",
            "function ERC20_FACTORY_ROLE() view returns (bytes32)",
            // AccessControl
            "function hasRole(bytes32 role, address account) view returns (bool)",
            "function grantRole(bytes32 role, address account)",
            "function revokeRole(bytes32 role, address account)",
            // Write functions
            "function addBridgeableToken(address token)",
            "function removeBridgeableToken(address token)",
            "function setPeer(uint32 eid, bytes32 peer)",
            "function setLzPaused(bool paused)",
            "function setFeeTreasury(address treasury)",
            "function addSigner(address signer)",
            "function removeSigner(address signer)",
            "function setRequiredSignatures(uint256 required)",
            // Quote functions
            "function quoteSend(address token, address recipient, bytes payload, uint32 dstEid) view returns (uint256)",
            // Events
            "event BridgeableTokenAdded(address indexed token)",
            "event BridgeableTokenRemoved(address indexed token)",
            "event LzPauseStateChanged(address indexed account, bool paused)",
            "event PeerSet(uint32 eid, bytes32 peer)"
        ];

        let routerV5 = null;

        let provider = null;
        let signer = null;
        let factory = null;
        let signerAddress = null;
        let roles = {};
        let isBeaconInit = false;
        let lastDeployedToken = null; // Store last deployed token data for verification

        // Loading state helper for buttons
        function setButtonLoading(btn, isLoading) {
            if (isLoading) {
                btn.dataset.originalText = btn.textContent;
                btn.classList.add('loading');
                btn.disabled = true;
            } else {
                btn.classList.remove('loading');
                btn.disabled = false;
                if (btn.dataset.originalText) {
                    btn.textContent = btn.dataset.originalText;
                }
            }
        }

        // Connect Wallet only (no factory auto-connect)
        async function connectWalletOnly() {
            const rpcUrl = document.getElementById('rpcUrl').value.trim();

            try {
                if (window.ethereum) {
                    provider = new ethers.BrowserProvider(window.ethereum);
                    await provider.send("eth_requestAccounts", []);
                    signer = await provider.getSigner();
                    signerAddress = await signer.getAddress();
                } else {
                    provider = new ethers.JsonRpcProvider(rpcUrl);
                    const accounts = await provider.listAccounts();
                    if (accounts.length > 0) {
                        signer = await provider.getSigner(0);
                        signerAddress = await signer.getAddress();
                    } else {
                        signerAddress = null;
                    }
                }

                // Get network info
                const network = await provider.getNetwork();
                const networkName = network.chainId === 80002n ? 'Amoy' :
                                   network.chainId === 137n ? 'Polygon' :
                                   network.chainId === 1n ? 'Ethereum' :
                                   `Chain ${network.chainId}`;

                const statusText = signer ? `${signerAddress.slice(0, 6)}...${signerAddress.slice(-4)} (${networkName})` : `Read-only (${networkName})`;
                document.getElementById('connectionStatus').className = 'status-pill connected';
                document.getElementById('connectionStatus').innerHTML = '<span class="dot"></span>' + statusText;

            } catch (error) {
                console.error('Wallet connection error:', error);
                document.getElementById('connectionStatus').className = 'status-pill disconnected';
                document.getElementById('connectionStatus').innerHTML = '<span class="dot"></span>Connection Failed';
                throw error;
            }
        }

        // Connect Wallet and auto-connect to Factory
        async function connectWallet() {
            try {
                await connectWalletOnly();

                // Auto-connect to Factory if address is provided
                const factoryAddr = document.getElementById('factoryAddress').value.trim();
                if (factoryAddr && ethers.isAddress(factoryAddr)) {
                    await connectFactory();
                }
            } catch (error) {
                alert('Failed to connect wallet: ' + error.message);
            }
        }

        // Connect to Factory contract
        async function connectFactory() {
            const factoryAddr = document.getElementById('factoryAddress').value.trim();

            if (!factoryAddr || !ethers.isAddress(factoryAddr)) {
                alert('Please enter a valid factory address');
                return;
            }

            // Connect wallet first if not connected
            if (!provider) {
                await connectWalletOnly();
            }

            if (!provider) {
                alert('Please connect wallet first');
                return;
            }

            try {
                factory = new ethers.Contract(factoryAddr, FACTORY_ABI, signer || provider);
                await factory.getDeployedTokensCount(); // Test connection

                document.getElementById('factoryStatus').className = 'status-pill connected';
                document.getElementById('factoryStatus').innerHTML = '<span class="dot"></span>Connected';

                // Hide the "Factory not connected" notice on Tokens tab
                document.getElementById('tokensFactoryNotice').style.display = 'none';

                await checkRoles();
                await checkBeaconStatus();
                await refreshInfo();
                await loadTokens();
                await updateDeployerLimits();

            } catch (error) {
                console.error('Factory connection error:', error);
                document.getElementById('factoryStatus').className = 'status-pill disconnected';
                document.getElementById('factoryStatus').innerHTML = '<span class="dot"></span>Failed';

                // Show notice on Tokens tab
                document.getElementById('tokensFactoryNotice').style.display = 'block';
            }
        }

        async function checkRoles() {
            if (!factory || !signerAddress) return;

            document.getElementById('rolesBar').style.display = 'flex';

            try {
                const [adminRole, deployerRole, beaconUpgraderRole, upgraderRole, pauserRole] = await Promise.all([
                    factory.DEFAULT_ADMIN_ROLE(),
                    factory.DEPLOYER_ROLE(),
                    factory.BEACON_UPGRADER_ROLE(),
                    factory.UPGRADER_ROLE(),
                    factory.PAUSER_ROLE()
                ]);

                const [hasAdmin, hasDeployer, hasBeaconUpgrader, hasUpgrader, hasPauser] = await Promise.all([
                    factory.hasRole(adminRole, signerAddress),
                    factory.hasRole(deployerRole, signerAddress),
                    factory.hasRole(beaconUpgraderRole, signerAddress),
                    factory.hasRole(upgraderRole, signerAddress),
                    factory.hasRole(pauserRole, signerAddress)
                ]);

                roles = {
                    admin: hasAdmin,
                    deployer: hasDeployer,
                    beaconUpgrader: hasBeaconUpgrader,
                    upgrader: hasUpgrader,
                    pauser: hasPauser,
                    adminRole, deployerRole, beaconUpgraderRole, upgraderRole, pauserRole
                };

                document.getElementById('roleAdmin').className = `role-badge ${hasAdmin ? 'active' : 'inactive'}`;
                document.getElementById('roleDeployer').className = `role-badge ${hasDeployer ? 'active' : 'inactive'}`;
                document.getElementById('roleBeaconUpgrader').className = `role-badge ${hasBeaconUpgrader ? 'active' : 'inactive'}`;
                document.getElementById('roleUpgrader').className = `role-badge ${hasUpgrader ? 'active' : 'inactive'}`;
                document.getElementById('rolePauser').className = `role-badge ${hasPauser ? 'active' : 'inactive'}`;

            } catch (e) {
                console.error('Error checking roles:', e);
            }
        }

        async function checkBeaconStatus() {
            if (!factory) return;

            try {
                isBeaconInit = await factory.isBeaconInitialized();
                const statusEl = document.getElementById('beaconStatus');
                const textEl = document.getElementById('beaconStatusText');
                const helpEl = document.getElementById('beaconHelpText');
                const iconEl = document.getElementById('beaconStatusIcon');

                statusEl.style.display = 'flex';

                if (isBeaconInit) {
                    statusEl.className = 'beacon-status initialized';
                    textEl.textContent = 'Beacon initialized';
                    helpEl.textContent = 'Ready for token deployment';
                    iconEl.innerHTML = '&#10003;';

                    // Load versions list
                    await loadVersions();
                } else {
                    statusEl.className = 'beacon-status not-initialized';
                    textEl.textContent = 'Beacon not initialized';
                    helpEl.textContent = 'Contact admin to deploy beacon first';
                    iconEl.innerHTML = '&#9888;';

                    document.getElementById('deployTokenCard').classList.add('disabled');
                }
            } catch (e) {
                console.error('Error checking beacon status:', e);
            }
        }

        async function loadVersions() {
            if (!factory) return;

            try {
                const [beacon, latestVersion, defaultVersion] = await Promise.all([
                    factory.erc20Beacon(),
                    factory.getLatestVersion(),
                    factory.getDefaultVersion()
                ]);

                document.getElementById('versionBeaconAddr').textContent = beacon;
                document.getElementById('versionLatest').textContent = latestVersion.toString();
                document.getElementById('versionDefault').textContent = defaultVersion.toString();

                const listEl = document.getElementById('versionsList');
                listEl.innerHTML = '';

                // Load all versions
                for (let v = 1; v <= Number(latestVersion); v++) {
                    const impl = await factory.getImplementationAtVersion(v);
                    const isDefault = v === Number(defaultVersion);

                    const item = document.createElement('div');
                    item.className = 'token-item';
                    item.style.cursor = 'default';
                    item.innerHTML = `
                        <div>
                            <span class="token-symbol">Version ${v}</span>
                            ${isDefault ? '<span class="badge badge-version" style="background: #22c55e33; color: #22c55e;">DEFAULT</span>' : ''}
                        </div>
                        <div class="token-address">${impl}</div>
                    `;
                    item.onclick = () => {
                        document.getElementById('newImpl').value = impl;
                        document.getElementById('defaultVersion').value = v;
                    };
                    listEl.appendChild(item);
                }
            } catch (error) {
                console.error('Error loading versions:', error);
                document.getElementById('versionsList').innerHTML = `<p style="color: #ef4444;">${error.message}</p>`;
            }
        }

        async function deployAndAddImplementation(btn) {
            if (!factory || !signer) {
                alert('Please connect with a wallet first');
                return;
            }

            const bytecode = document.getElementById('newImplBytecode').value.trim();
            const resultEl = document.getElementById('versionResult');
            resultEl.classList.remove('hidden');

            if (!bytecode || !bytecode.startsWith('0x')) {
                resultEl.textContent = 'Error: Please enter valid bytecode starting with 0x';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                resultEl.textContent = 'Deploying new implementation contract...';
                resultEl.className = 'result';

                // Deploy the implementation contract manually
                const contractFactory = new ethers.ContractFactory([], bytecode, signer);
                const deployTx = await contractFactory.deploy();
                resultEl.textContent = `Deploying implementation...\nTx: ${deployTx.deploymentTransaction().hash}`;

                await deployTx.waitForDeployment();
                const implAddress = await deployTx.getAddress();

                resultEl.textContent = `Implementation deployed at: ${implAddress}\nAdding to beacon...`;

                // Add to beacon
                const tx = await factory.addImplementationVersion(implAddress);
                resultEl.textContent = `Adding to beacon...\nTx: ${tx.hash}`;

                await tx.wait();

                const newVersion = await factory.getLatestVersion();
                resultEl.textContent = `Success!\nImplementation: ${implAddress}\nVersion: ${newVersion}\nSet as default for new tokens.`;
                resultEl.className = 'result success';

                await loadVersions();
                await refreshInfo();

            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function updateDeployerLimits() {
            if (!factory || !signerAddress) return;
            try {
                const limit = await factory.getUserDeploymentLimit(signerAddress);
                const deployed = await factory.getUserDeployedCount(signerAddress);
                document.getElementById('yourLimit').textContent = limit.toString();
                document.getElementById('yourDeployed').textContent = deployed.toString();

                // Auto-find next available slug
                await updateNextAvailableSlug();
            } catch (e) { console.error(e); }
        }

        async function updateNextAvailableSlug() {
            if (!factory || !signerAddress) return;
            try {
                // Find next available slug (start from 1, check up to 1000)
                let nextSlug = 1;
                for (let i = 1; i <= 1000; i++) {
                    const isUsed = await factory.isSlugUsed(signerAddress, i);
                    if (!isUsed) {
                        nextSlug = i;
                        break;
                    }
                }
                document.getElementById('tokenSlug').value = nextSlug;
            } catch (e) { console.error('Error finding next slug:', e); }
        }

        // ==================== QUERY DATA FUNCTIONS ====================

        async function lookupBySymbol(btn) {
            if (!factory) return alert('Please connect first');

            const symbol = document.getElementById('lookupSymbol').value.trim();
            const resultEl = document.getElementById('lookupSymbolResult');
            resultEl.classList.remove('hidden');

            if (!symbol) {
                resultEl.textContent = 'Please enter a symbol';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const tokenAddr = await factory.getTokenBySymbol(symbol);

                if (tokenAddr === '0x0000000000000000000000000000000000000000') {
                    resultEl.textContent = `No token found with symbol "${symbol}"`;
                    resultEl.className = 'result error';
                } else {
                    const token = new ethers.Contract(tokenAddr, TOKEN_ABI, provider);
                    const [name, decimals, version, owner] = await Promise.all([
                        token.name(),
                        token.decimals(),
                        factory.getTokenVersion(tokenAddr),
                        factory.tokenOwner(tokenAddr)
                    ]);

                    resultEl.innerHTML = `
                        <strong>Found: ${name} (${symbol})</strong><br>
                        Address: ${tokenAddr}<br>
                        Decimals: ${decimals}<br>
                        Version: ${version}<br>
                        Owner: ${owner}
                    `;
                    resultEl.className = 'result success';
                }
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function lookupTokenInfo(btn) {
            if (!factory) return alert('Please connect first');

            const tokenAddr = document.getElementById('tokenInfoAddr').value.trim();
            const resultEl = document.getElementById('tokenInfoResult');
            resultEl.classList.remove('hidden');

            if (!tokenAddr || !ethers.isAddress(tokenAddr)) {
                resultEl.textContent = 'Please enter a valid address';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const token = new ethers.Contract(tokenAddr, TOKEN_ABI, provider);
                const [name, symbol, decimals, totalSupply, version, impl, owner] = await Promise.all([
                    token.name(),
                    token.symbol(),
                    token.decimals(),
                    token.totalSupply(),
                    factory.getTokenVersion(tokenAddr),
                    factory.getTokenImplementation(tokenAddr),
                    factory.tokenOwner(tokenAddr)
                ]);

                const formattedSupply = ethers.formatUnits(totalSupply, decimals);

                resultEl.innerHTML = `
                    <strong>${name} (${symbol})</strong><br>
                    Decimals: ${decimals}<br>
                    Total Supply: ${formattedSupply}<br>
                    Version: ${version}<br>
                    Implementation: <span style="font-size: 0.85em;">${impl}</span><br>
                    Owner: <span style="font-size: 0.85em;">${owner}</span>
                `;
                resultEl.className = 'result success';
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function lookupTokensByOwner(btn) {
            if (!factory) return alert('Please connect first');

            let ownerAddr = document.getElementById('ownerLookupAddr').value.trim();
            const resultEl = document.getElementById('ownerTokensResult');
            resultEl.classList.remove('hidden');

            if (!ownerAddr) {
                if (signerAddress) {
                    ownerAddr = signerAddress;
                } else {
                    resultEl.textContent = 'Please enter an address or connect wallet';
                    resultEl.className = 'result error';
                    return;
                }
            }

            if (!ethers.isAddress(ownerAddr)) {
                resultEl.textContent = 'Please enter a valid address';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const tokens = await factory.getTokensByOwner(ownerAddr);

                if (tokens.length === 0) {
                    resultEl.textContent = `No tokens owned by ${ownerAddr.slice(0,6)}...${ownerAddr.slice(-4)}`;
                    resultEl.className = 'result';
                } else {
                    let html = `<strong>Tokens owned by ${ownerAddr.slice(0,6)}...${ownerAddr.slice(-4)} (${tokens.length}):</strong><br><br>`;

                    for (const addr of tokens) {
                        try {
                            const token = new ethers.Contract(addr, TOKEN_ABI, provider);
                            const [name, symbol] = await Promise.all([token.name(), token.symbol()]);
                            html += ` <strong>${symbol}</strong> - ${name}<br><span style="font-size: 0.85em; color: #666;">${addr}</span><br><br>`;
                        } catch {
                            html += ` ${addr}<br>`;
                        }
                    }

                    resultEl.innerHTML = html;
                    resultEl.className = 'result success';
                }
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function checkSlugUsage(btn) {
            if (!factory) return alert('Please connect first');

            let deployer = document.getElementById('slugDeployer').value.trim();
            const slug = parseInt(document.getElementById('slugNumber').value);
            const resultEl = document.getElementById('slugResult');
            resultEl.classList.remove('hidden');

            if (!deployer) {
                if (signerAddress) {
                    deployer = signerAddress;
                } else {
                    resultEl.textContent = 'Please enter a deployer address or connect wallet';
                    resultEl.className = 'result error';
                    return;
                }
            }

            if (!ethers.isAddress(deployer)) {
                resultEl.textContent = 'Please enter a valid address';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const isUsed = await factory.isSlugUsed(deployer, slug);

                if (isUsed) {
                    resultEl.innerHTML = `<span style="color: #ef4444;"> Slug ${slug} is <strong>USED</strong></span><br>for deployer ${deployer.slice(0,6)}...${deployer.slice(-4)}`;
                    resultEl.className = 'result';
                } else {
                    resultEl.innerHTML = `<span style="color: #22c55e;"> Slug ${slug} is <strong>AVAILABLE</strong></span><br>for deployer ${deployer.slice(0,6)}...${deployer.slice(-4)}`;
                    resultEl.className = 'result success';
                }
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function lookupUserInfo(btn) {
            if (!factory) return alert('Please connect first');

            let userAddr = document.getElementById('userInfoAddr').value.trim();
            const resultEl = document.getElementById('userInfoResult');
            resultEl.classList.remove('hidden');

            if (!userAddr) {
                if (signerAddress) {
                    userAddr = signerAddress;
                } else {
                    resultEl.textContent = 'Please enter an address or connect wallet';
                    resultEl.className = 'result error';
                    return;
                }
            }

            if (!ethers.isAddress(userAddr)) {
                resultEl.textContent = 'Please enter a valid address';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const [limit, deployed, tokens] = await Promise.all([
                    factory.getUserDeploymentLimit(userAddr),
                    factory.getUserDeployedCount(userAddr),
                    factory.getTokensByOwner(userAddr)
                ]);

                const remaining = Number(limit) - Number(deployed);

                resultEl.innerHTML = `
                    <strong>User: ${userAddr.slice(0,6)}...${userAddr.slice(-4)}</strong><br><br>
                    Deployment Limit: <strong>${limit}</strong><br>
                    Deployed Count: <strong>${deployed}</strong><br>
                    Remaining: <strong style="color: ${remaining > 0 ? '#22c55e' : '#ef4444'};">${remaining}</strong><br>
                    Tokens Owned: <strong>${tokens.length}</strong>
                `;
                resultEl.className = 'result success';
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function checkRole(btn) {
            if (!factory) return alert('Please connect first');

            const roleName = document.getElementById('checkRoleSelect').value;
            let addr = document.getElementById('checkRoleAddr').value.trim();
            const resultEl = document.getElementById('checkRoleResult');
            resultEl.classList.remove('hidden');

            if (!addr) {
                if (signerAddress) {
                    addr = signerAddress;
                } else {
                    resultEl.textContent = 'Please enter an address or connect wallet';
                    resultEl.className = 'result error';
                    return;
                }
            }

            if (!ethers.isAddress(addr)) {
                resultEl.textContent = 'Please enter a valid address';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const roleHash = await factory[roleName]();
                const hasRole = await factory.hasRole(roleHash, addr);

                if (hasRole) {
                    resultEl.innerHTML = `<span style="color: #22c55e;"> Address <strong>HAS</strong> ${roleName}</span><br>${addr.slice(0,6)}...${addr.slice(-4)}`;
                    resultEl.className = 'result success';
                } else {
                    resultEl.innerHTML = `<span style="color: #ef4444;"> Address does <strong>NOT</strong> have ${roleName}</span><br>${addr.slice(0,6)}...${addr.slice(-4)}`;
                    resultEl.className = 'result';
                }
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        // ==================== END QUERY DATA FUNCTIONS ====================

        async function refreshInfo() {
            if (!factory) return;
            try {
                const isInit = await factory.isBeaconInitialized();
                document.getElementById('infoBeaconInit').textContent = isInit ? 'Yes' : 'No';

                if (isInit) {
                    const [beacon, impl, router, latestVer, defaultVer, tokenCount, defaultLimit, paused] = await Promise.all([
                        factory.erc20Beacon(),
                        factory.erc20Implementation(),
                        factory.router(),
                        factory.getLatestVersion(),
                        factory.getDefaultVersion(),
                        factory.getDeployedTokensCount(),
                        factory.defaultDeploymentLimit(),
                        factory.paused()
                    ]);

                    document.getElementById('infoFactoryAddr').textContent = await factory.getAddress();
                    document.getElementById('infoBeacon').textContent = beacon;
                    document.getElementById('infoImpl').textContent = impl;
                    document.getElementById('infoLatestVer').textContent = latestVer.toString();
                    document.getElementById('infoDefaultVer').textContent = defaultVer.toString();
                    document.getElementById('infoRouter').textContent = router === '0x0000000000000000000000000000000000000000' ? '(not set)' : router;
                    document.getElementById('infoTokenCount').textContent = tokenCount.toString();
                    document.getElementById('infoDefaultLimit').textContent = defaultLimit.toString();
                    document.getElementById('infoPaused').textContent = paused ? 'Yes' : 'No';
                } else {
                    document.getElementById('infoFactoryAddr').textContent = await factory.getAddress();
                    document.getElementById('infoBeacon').textContent = '(not deployed)';
                    document.getElementById('infoImpl').textContent = '(not deployed)';
                    document.getElementById('infoLatestVer').textContent = '-';
                    document.getElementById('infoDefaultVer').textContent = '-';

                    const [router, tokenCount, defaultLimit, paused] = await Promise.all([
                        factory.router(),
                        factory.getDeployedTokensCount(),
                        factory.defaultDeploymentLimit(),
                        factory.paused()
                    ]);
                    document.getElementById('infoRouter').textContent = router === '0x0000000000000000000000000000000000000000' ? '(not set)' : router;
                    document.getElementById('infoTokenCount').textContent = tokenCount.toString();
                    document.getElementById('infoDefaultLimit').textContent = defaultLimit.toString();
                    document.getElementById('infoPaused').textContent = paused ? 'Yes' : 'No';
                }
                // Try to connect to Router V5
                const router = isInit ? await factory.router() : null;
                if (router && router !== ethers.ZeroAddress) {
                    await connectToRouterV5(router);
                }

            } catch (error) {
                console.error('Error refreshing info:', error);
            }
        }

        async function loadTokens() {
            if (!factory) return;
            const listEl = document.getElementById('tokenList');

            try {
                const isInit = await factory.isBeaconInitialized();
                if (!isInit) {
                    listEl.innerHTML = '<p style="color: #666; text-align: center;">Beacon not initialized yet</p>';
                    return;
                }

                const count = await factory.getDeployedTokensCount();
                if (count === 0n) {
                    listEl.innerHTML = '<p style="color: #666; text-align: center;">No tokens deployed yet</p>';
                    return;
                }

                const tokens = await factory.getDeployedTokens(0, count);
                listEl.innerHTML = '<p style="color: #666; text-align: center;">Loading tokens...</p>';

                // Reverse to show newest first
                const reversedTokens = [...tokens].reverse();

                const beaconAddress = await factory.erc20Beacon();
                const network = await provider.getNetwork();
                const networkName = getNetworkName(network.chainId);

                // Check verification status for all tokens in parallel
                const verificationPromises = reversedTokens.map(addr => isContractVerified(addr, networkName));
                const verificationStatuses = await Promise.all(verificationPromises);

                listEl.innerHTML = '';

                for (let i = 0; i < reversedTokens.length; i++) {
                    const addr = reversedTokens[i];
                    const isVerified = verificationStatuses[i];

                    try {
                        const token = new ethers.Contract(addr, TOKEN_ABI, provider);
                        const [name, symbol, decimals, version, owner] = await Promise.all([
                            token.name(),
                            token.symbol(),
                            token.decimals(),
                            factory.getTokenVersion(addr),
                            factory.tokenOwner(addr)
                        ]);

                        // Escape quotes in name/symbol for onclick handler
                        const escapedName = name.replace(/'/g, "\\'");
                        const escapedSymbol = symbol.replace(/'/g, "\\'");

                        const item = document.createElement('div');
                        item.className = 'token-item';

                        // Show "Verified" badge or "Verify" button based on status
                        const verifySection = isVerified === true
                            ? `<span style="margin-top: 8px; display: inline-block; padding: 6px 12px; font-size: 0.85em; background: #dcfce7; color: #16a34a; border-radius: 6px;"> Verified</span>`
                            : `<button class="btn btn-primary" style="margin-top: 8px; padding: 6px 12px; font-size: 0.85em;" onclick="event.stopPropagation(); verifyToken('${addr}', '${beaconAddress}', '${escapedName}', '${escapedSymbol}', ${decimals}, '${networkName}')">Verify on Explorer</button>`;

                        item.innerHTML = `
                            <div><span class="token-symbol">${symbol}</span><span class="badge badge-version">v${version}</span></div>
                            <div>${name}</div>
                            <div class="token-address">${addr}</div>
                            <div class="token-owner">Owner: ${owner.slice(0,6)}...${owner.slice(-4)}</div>
                            ${verifySection}
                        `;
                        item.onclick = () => {
                            document.getElementById('upgradeTokenAddr').value = addr;
                            document.getElementById('transferTokenAddr').value = addr;
                        };
                        listEl.appendChild(item);
                    } catch (tokenError) {
                        console.error(`Error loading token ${addr}:`, tokenError);
                        const item = document.createElement('div');
                        item.className = 'token-item';
                        item.innerHTML = `
                            <div class="token-address">${addr}</div>
                            <div style="color: #ef4444; font-size: 0.85em;">Error loading token data</div>
                        `;
                        listEl.appendChild(item);
                    }
                }
            } catch (error) {
                listEl.innerHTML = `<p style="color: #ef4444;">${error.message}</p>`;
            }
        }


        async function deployToken() {
            if (!factory || !signer) {
                alert('Please connect with a wallet first');
                return;
            }

            const name = document.getElementById('tokenName').value.trim();
            const symbol = document.getElementById('tokenSymbol').value.trim();
            const decimals = parseInt(document.getElementById('tokenDecimals').value);
            const slug = parseInt(document.getElementById('tokenSlug').value);

            if (!name || !symbol) {
                alert('Please fill in name and symbol');
                return;
            }

            const btn = document.getElementById('deployTokenBtn');
            const resultEl = document.getElementById('deployResult');
            resultEl.className = 'result';
            resultEl.classList.remove('hidden');
            resultEl.textContent = 'Deploying token...';
            setButtonLoading(btn, true);

            try {
                const tx = await factory.deployERC20Token(name, symbol, decimals, slug);
                resultEl.textContent = `Transaction sent: ${tx.hash}\nWaiting for confirmation...`;

                const receipt = await tx.wait();
                const event = receipt.logs.find(log => {
                    try {
                        return factory.interface.parseLog(log)?.name === 'ERC20TokenDeployed';
                    } catch { return false; }
                });

                if (event) {
                    const parsed = factory.interface.parseLog(event);
                    const tokenAddress = parsed.args.tokenAddress;
                    resultEl.textContent = `Token deployed!\nAddress: ${tokenAddress}\nOwner: ${parsed.args.owner}\nTx: ${tx.hash}`;
                    resultEl.className = 'result success';

                    // Store data for verification
                    const beaconAddress = await factory.erc20Beacon();
                    const network = await provider.getNetwork();
                    lastDeployedToken = {
                        tokenAddress,
                        beaconAddress,
                        name,
                        symbol,
                        decimals,
                        network: getNetworkName(network.chainId)
                    };

                    // Show verify button and configure button
                    document.getElementById('verifyDeployedBtn').classList.remove('hidden');
                    document.getElementById('configureDeployedBtn').classList.remove('hidden');

                    // Auto-fill configure token address
                    document.getElementById('configureTokenAddr').value = tokenAddress;
                    document.getElementById('bridgeTokenAddr').value = tokenAddress;

                    // Check if router is set and suggest configuration
                    const routerAddr = await factory.router();
                    if (routerAddr && routerAddr !== ethers.ZeroAddress) {
                        resultEl.textContent += `\n\n Router detected! Click "Configure for Bridge" to enable cross-chain bridging.`;
                    }
                } else {
                    resultEl.textContent = `Token deployed!\nTx: ${tx.hash}`;
                    resultEl.className = 'result success';
                }

                await refreshInfo();
                await loadTokens();
                await updateDeployerLimits();

            } catch (error) {
                let errorMsg = error.reason || error.message;
                // Decode AccessControl error
                if (error.data && error.data.startsWith('0xe2517d3f')) {
                    errorMsg = 'Access Denied: Your wallet does not have DEPLOYER_ROLE.\n\nAsk the admin to grant you the role, or switch to the admin wallet.';
                }
                resultEl.textContent = `Error: ${errorMsg}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function computeAddress() {
            if (!factory) return alert('Please connect first');

            const name = document.getElementById('tokenName').value.trim();
            const symbol = document.getElementById('tokenSymbol').value.trim();
            const decimals = parseInt(document.getElementById('tokenDecimals').value);
            let deployer = signerAddress;
            const slug = parseInt(document.getElementById('tokenSlug').value);

            if (!name || !symbol) return alert('Please fill in name and symbol');

            const resultEl = document.getElementById('deployResult');
            resultEl.classList.remove('hidden');

            try {
                const address = await factory.computeERC20Address(name, symbol, decimals, deployer, slug);
                resultEl.textContent = `Computed address: ${address}`;
                resultEl.className = 'result success';
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            }
        }

        async function upgradeToken(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');

            const tokenAddr = document.getElementById('upgradeTokenAddr').value.trim();
            const version = parseInt(document.getElementById('upgradeVersion').value);
            const resultEl = document.getElementById('upgradeResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const tx = await factory.upgradeToken(tokenAddr, version);
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `Token upgraded to version ${version}!`;
                resultEl.className = 'result success';
                await loadTokens();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function transferOwnership(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');

            const tokenAddr = document.getElementById('transferTokenAddr').value.trim();
            const newOwner = document.getElementById('newOwnerAddr').value.trim();
            const resultEl = document.getElementById('transferResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const tx = await factory.transferTokenOwnership(tokenAddr, newOwner);
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `Ownership transferred to ${newOwner}`;
                resultEl.className = 'result success';
                await loadTokens();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function setUserLimit(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');

            const user = document.getElementById('limitUserAddr').value.trim();
            const limit = parseInt(document.getElementById('limitValue').value);
            const resultEl = document.getElementById('limitResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const tx = await factory.setUserDeploymentLimit(user, limit);
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `User ${user} limit set to ${limit}`;
                resultEl.className = 'result success';
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function setDefaultLimit(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');

            const limit = parseInt(document.getElementById('defaultLimitValue').value);
            const resultEl = document.getElementById('limitResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const tx = await factory.setDefaultDeploymentLimit(limit);
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `Default limit set to ${limit}`;
                resultEl.className = 'result success';
                await refreshInfo();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function setRouter(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');

            const newRouter = document.getElementById('newRouter').value.trim();
            const resultEl = document.getElementById('routerResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const tx = await factory.setRouter(newRouter);
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `Router updated to: ${newRouter}`;
                resultEl.className = 'result success';
                await refreshInfo();
                // Also refresh router V5 info
                await refreshRouterV5Info();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        // ==================== ROUTER V5 FUNCTIONS ====================

        // User-triggered connect from input field
        async function connectRouterV5() {
            const routerAddr = document.getElementById('routerV5Address').value.trim();
            if (!routerAddr || !ethers.isAddress(routerAddr)) {
                alert('Please enter a valid Router V5 address');
                return;
            }
            await connectToRouterV5(routerAddr);
        }

        async function connectToRouterV5(routerAddr) {
            if (!routerAddr || routerAddr === ethers.ZeroAddress) {
                routerV5 = null;
                document.getElementById('routerV5StatusText').textContent = 'No router configured';
                document.getElementById('routerV5StatusText').style.color = '#9ca3af';
                return;
            }

            try {
                routerV5 = new ethers.Contract(routerAddr, ROUTER_V5_ABI, signer || provider);
                // Test the connection
                await routerV5.lzPaused();
                document.getElementById('routerV5StatusText').textContent = `Connected: ${routerAddr.slice(0,6)}...${routerAddr.slice(-4)}`;
                document.getElementById('routerV5StatusText').style.color = '#22c55e';
                await refreshRouterV5Info();
            } catch (e) {
                console.error('Router V5 connection error:', e);
                routerV5 = null;
                document.getElementById('routerV5StatusText').textContent = 'Connection failed (not a V5 router?)';
                document.getElementById('routerV5StatusText').style.color = '#ef4444';
            }
        }

        async function refreshRouterV5Info() {
            if (!routerV5) {
                // Try to connect using the Router V5 input field
                const routerAddr = document.getElementById('routerV5Address').value.trim();
                if (routerAddr && ethers.isAddress(routerAddr)) {
                    await connectToRouterV5(routerAddr);
                }
                if (!routerV5) return;
            }

            try {
                const [lzPaused, treasury, signers, requiredSigs] = await Promise.all([
                    routerV5.lzPaused(),
                    routerV5.feeTreasury(),
                    routerV5.signers(),
                    routerV5.requiredSignatures()
                ]);

                document.getElementById('infoRouterV5Addr').textContent = await routerV5.getAddress();
                document.getElementById('infoRouterPaused').textContent = lzPaused ? 'Yes ' : 'No ';
                document.getElementById('infoRouterPaused').style.color = lzPaused ? '#ef4444' : '#22c55e';
                document.getElementById('infoRouterTreasury').textContent = treasury;
                document.getElementById('infoRouterSigs').textContent = `${requiredSigs} of ${signers.length}`;

                // Check user's roles
                if (signerAddress) {
                    const [adminRole, pauserRole, factoryRole] = await Promise.all([
                        routerV5.DEFAULT_ADMIN_ROLE(),
                        routerV5.PAUSER_ROLE(),
                        routerV5.ERC20_FACTORY_ROLE()
                    ]);
                    const [hasAdmin, hasPauser, hasFactory] = await Promise.all([
                        routerV5.hasRole(adminRole, signerAddress),
                        routerV5.hasRole(pauserRole, signerAddress),
                        routerV5.hasRole(factoryRole, signerAddress)
                    ]);
                    const rolesList = [];
                    if (hasAdmin) rolesList.push('ADMIN');
                    if (hasPauser) rolesList.push('PAUSER');
                    if (hasFactory) rolesList.push('FACTORY');
                    document.getElementById('infoRouterYourRole').textContent = rolesList.length > 0 ? rolesList.join(', ') : 'None';
                    document.getElementById('infoRouterYourRole').style.color = rolesList.length > 0 ? '#22c55e' : '#9ca3af';
                }
            } catch (e) {
                console.error('Error refreshing router V5 info:', e);
            }
        }

        async function configureTokenForBridge(btn) {
            if (!signer) return alert('Please connect with a wallet first');

            const tokenAddr = document.getElementById('configureTokenAddr').value.trim();
            const resultEl = document.getElementById('configureResult');
            resultEl.classList.remove('hidden');

            if (!tokenAddr || !ethers.isAddress(tokenAddr)) {
                resultEl.textContent = 'Please enter a valid token address';
                resultEl.className = 'result error';
                return;
            }

            // Get router address from Router V5 input field (separate from Factory's V3 router)
            let routerAddr = document.getElementById('routerV5Address').value.trim();
            if (!routerAddr || !ethers.isAddress(routerAddr)) {
                resultEl.textContent = 'Error: Please enter Router V5 address and click "Connect Router V5" first.';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const token = new ethers.Contract(tokenAddr, TOKEN_ABI, signer);
                const routerRole = await token.ROUTER_ROLE();

                // Check if already configured
                const hasRouterRole = await token.hasRole(routerRole, routerAddr);

                resultEl.textContent = 'Step 1/2: Granting ROUTER_ROLE to router...';
                resultEl.className = 'result';

                if (!hasRouterRole) {
                    const tx1 = await token.grantRole(routerRole, routerAddr);
                    resultEl.textContent = `Step 1/2: Tx sent ${tx1.hash.slice(0,10)}... waiting...`;
                    await tx1.wait();
                    resultEl.textContent = 'Step 1/2: ROUTER_ROLE granted \nStep 2/2: Adding to router whitelist...';
                } else {
                    resultEl.textContent = 'Step 1/2: ROUTER_ROLE already granted \nStep 2/2: Adding to router whitelist...';
                }

                // Step 2: Add to router's bridgeable whitelist
                if (!routerV5) {
                    await connectToRouterV5(routerAddr);
                }

                if (routerV5) {
                    const isBridgeable = await routerV5.isBridgeableToken(tokenAddr);
                    if (!isBridgeable) {
                        const tx2 = await routerV5.addBridgeableToken(tokenAddr);
                        resultEl.textContent += `\nTx sent ${tx2.hash.slice(0,10)}... waiting...`;
                        await tx2.wait();
                        resultEl.textContent = ` Token configured for bridging!\n\nROUTER_ROLE: Granted\nWhitelist: Added\n\nToken: ${tokenAddr}\nRouter: ${routerAddr}`;
                        resultEl.className = 'result success';
                    } else {
                        resultEl.textContent = ` Token already configured for bridging!\n\nROUTER_ROLE: ${hasRouterRole ? 'Already granted' : 'Granted'}\nWhitelist: Already added\n\nToken: ${tokenAddr}`;
                        resultEl.className = 'result success';
                    }
                } else {
                    resultEl.textContent += '\n\n Could not add to router whitelist.\nRouter may not be V5 or you need ERC20_FACTORY_ROLE on router.';
                    resultEl.className = 'result';
                }

            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function grantRouterRole(btn) {
            if (!signer) return alert('Please connect with a wallet first');

            const tokenAddr = document.getElementById('grantRouterRoleTokenAddr').value.trim();
            const resultEl = document.getElementById('grantRouterRoleResult');
            resultEl.classList.remove('hidden');

            if (!tokenAddr || !ethers.isAddress(tokenAddr)) {
                resultEl.textContent = 'Please enter a valid token address';
                resultEl.className = 'result error';
                return;
            }

            // Get router address from Router V5 input field
            let routerAddr = document.getElementById('routerV5Address').value.trim();
            if (!routerAddr || !ethers.isAddress(routerAddr)) {
                resultEl.textContent = 'Error: Please enter Router V5 address and click "Connect Router V5" first.';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const token = new ethers.Contract(tokenAddr, TOKEN_ABI, signer);
                const routerRole = await token.ROUTER_ROLE();

                const tx = await token.grantRole(routerRole, routerAddr);
                resultEl.textContent = `Transaction sent: ${tx.hash}\nWaiting...`;
                await tx.wait();
                resultEl.textContent = ` ROUTER_ROLE granted to Router V5!\n\nToken: ${tokenAddr}\nRouter V5: ${routerAddr}`;
                resultEl.className = 'result success';
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function addToBridgeable(btn) {
            if (!signer) return alert('Please connect with a wallet first');

            const tokenAddr = document.getElementById('addWhitelistTokenAddr').value.trim();
            const resultEl = document.getElementById('addWhitelistResult');
            resultEl.classList.remove('hidden');

            if (!tokenAddr || !ethers.isAddress(tokenAddr)) {
                resultEl.textContent = 'Please enter a valid token address';
                resultEl.className = 'result error';
                return;
            }

            if (!routerV5) {
                // Try to connect using the Router V5 input field
                const routerAddr = document.getElementById('routerV5Address').value.trim();
                if (routerAddr && ethers.isAddress(routerAddr)) {
                    await connectToRouterV5(routerAddr);
                }
            }

            if (!routerV5) {
                resultEl.textContent = 'Error: Router V5 not connected. Enter Router V5 address and click "Connect Router V5" first.';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const tx = await routerV5.addBridgeableToken(tokenAddr);
                resultEl.textContent = `Transaction sent: ${tx.hash}\nWaiting...`;
                await tx.wait();
                resultEl.textContent = ` Token added to bridgeable whitelist!\n\nToken: ${tokenAddr}`;
                resultEl.className = 'result success';
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function removeFromBridgeable(btn) {
            if (!signer) return alert('Please connect with a wallet first');

            const tokenAddr = document.getElementById('removeWhitelistTokenAddr').value.trim();
            const resultEl = document.getElementById('removeWhitelistResult');
            resultEl.classList.remove('hidden');

            if (!tokenAddr || !ethers.isAddress(tokenAddr)) {
                resultEl.textContent = 'Please enter a valid token address';
                resultEl.className = 'result error';
                return;
            }

            if (!routerV5) {
                resultEl.textContent = 'Error: Router V5 not connected';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const tx = await routerV5.removeBridgeableToken(tokenAddr);
                resultEl.textContent = `Transaction sent: ${tx.hash}\nWaiting...`;
                await tx.wait();
                resultEl.textContent = ` Token removed from bridgeable whitelist!\n\nToken: ${tokenAddr}`;
                resultEl.className = 'result success';
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function setFeeTreasury(btn) {
            if (!signer) return alert('Please connect with a wallet first');

            const treasuryAddr = document.getElementById('setTreasuryAddr').value.trim();
            const resultEl = document.getElementById('setTreasuryResult');
            resultEl.classList.remove('hidden');

            if (!treasuryAddr || !ethers.isAddress(treasuryAddr)) {
                resultEl.textContent = 'Please enter a valid treasury address';
                resultEl.className = 'result error';
                return;
            }

            if (!routerV5) {
                const routerAddr = document.getElementById('routerV5Address').value.trim();
                if (routerAddr && ethers.isAddress(routerAddr)) {
                    await connectToRouterV5(routerAddr);
                }
            }

            if (!routerV5) {
                resultEl.textContent = 'Error: Router V5 not connected';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const tx = await routerV5.setFeeTreasury(treasuryAddr);
                resultEl.textContent = `Transaction sent: ${tx.hash}\nWaiting...`;
                await tx.wait();
                resultEl.textContent = ` Fee treasury set to ${treasuryAddr}`;
                resultEl.className = 'result success';
                await refreshRouterV5Info();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function addSigner(btn) {
            if (!signer) return alert('Please connect with a wallet first');

            const signerAddr = document.getElementById('addSignerAddr').value.trim();
            const resultEl = document.getElementById('addSignerResult');
            resultEl.classList.remove('hidden');

            if (!signerAddr || !ethers.isAddress(signerAddr)) {
                resultEl.textContent = 'Please enter a valid signer address';
                resultEl.className = 'result error';
                return;
            }

            if (!routerV5) {
                const routerAddr = document.getElementById('routerV5Address').value.trim();
                if (routerAddr && ethers.isAddress(routerAddr)) {
                    await connectToRouterV5(routerAddr);
                }
            }

            if (!routerV5) {
                resultEl.textContent = 'Error: Router V5 not connected';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const tx = await routerV5.addSigner(signerAddr);
                resultEl.textContent = `Transaction sent: ${tx.hash}\nWaiting...`;
                await tx.wait();
                resultEl.textContent = ` Signer added: ${signerAddr}`;
                resultEl.className = 'result success';
                await refreshRouterV5Info();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function removeSigner(btn) {
            if (!signer) return alert('Please connect with a wallet first');

            const signerAddr = document.getElementById('removeSignerAddr').value.trim();
            const resultEl = document.getElementById('removeSignerResult');
            resultEl.classList.remove('hidden');

            if (!signerAddr || !ethers.isAddress(signerAddr)) {
                resultEl.textContent = 'Please enter a valid signer address';
                resultEl.className = 'result error';
                return;
            }

            if (!routerV5) {
                const routerAddr = document.getElementById('routerV5Address').value.trim();
                if (routerAddr && ethers.isAddress(routerAddr)) {
                    await connectToRouterV5(routerAddr);
                }
            }

            if (!routerV5) {
                resultEl.textContent = 'Error: Router V5 not connected';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const tx = await routerV5.removeSigner(signerAddr);
                resultEl.textContent = `Transaction sent: ${tx.hash}\nWaiting...`;
                await tx.wait();
                resultEl.textContent = ` Signer removed: ${signerAddr}`;
                resultEl.className = 'result success';
                await refreshRouterV5Info();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function setRequiredSignatures(btn) {
            if (!signer) return alert('Please connect with a wallet first');

            const requiredNum = parseInt(document.getElementById('setRequiredSigsNum').value);
            const resultEl = document.getElementById('setRequiredSigsResult');
            resultEl.classList.remove('hidden');

            if (isNaN(requiredNum) || requiredNum < 1) {
                resultEl.textContent = 'Please enter a valid number (minimum 1)';
                resultEl.className = 'result error';
                return;
            }

            if (!routerV5) {
                const routerAddr = document.getElementById('routerV5Address').value.trim();
                if (routerAddr && ethers.isAddress(routerAddr)) {
                    await connectToRouterV5(routerAddr);
                }
            }

            if (!routerV5) {
                resultEl.textContent = 'Error: Router V5 not connected';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const tx = await routerV5.setRequiredSignatures(requiredNum);
                resultEl.textContent = `Transaction sent: ${tx.hash}\nWaiting...`;
                await tx.wait();
                resultEl.textContent = ` Required signatures set to: ${requiredNum}`;
                resultEl.className = 'result success';
                await refreshRouterV5Info();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function grantFactoryRole(btn) {
            if (!signer) return alert('Please connect with a wallet first');

            const factoryAddr = document.getElementById('grantFactoryRoleAddr').value.trim();
            const resultEl = document.getElementById('grantFactoryRoleResult');
            resultEl.classList.remove('hidden');

            if (!factoryAddr || !ethers.isAddress(factoryAddr)) {
                resultEl.textContent = 'Please enter a valid factory address';
                resultEl.className = 'result error';
                return;
            }

            if (!routerV5) {
                const routerAddr = document.getElementById('routerV5Address').value.trim();
                if (routerAddr && ethers.isAddress(routerAddr)) {
                    await connectToRouterV5(routerAddr);
                }
            }

            if (!routerV5) {
                resultEl.textContent = 'Error: Router V5 not connected';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                const factoryRole = await routerV5.ERC20_FACTORY_ROLE();
                const tx = await routerV5.grantRole(factoryRole, factoryAddr);
                resultEl.textContent = `Transaction sent: ${tx.hash}\nWaiting...`;
                await tx.wait();
                resultEl.textContent = ` ERC20_FACTORY_ROLE granted to: ${factoryAddr}`;
                resultEl.className = 'result success';
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function checkTokenBridgeStatus(btn) {
            const tokenAddr = document.getElementById('checkStatusTokenAddr').value.trim();
            const resultEl = document.getElementById('checkStatusResult');
            resultEl.classList.remove('hidden');

            if (!tokenAddr || !ethers.isAddress(tokenAddr)) {
                resultEl.textContent = 'Please enter a valid token address';
                resultEl.className = 'result error';
                return;
            }

            setButtonLoading(btn, true);

            try {
                // Get Router V5 address from input field
                let routerAddr = document.getElementById('routerV5Address').value.trim();
                if (!routerAddr || !ethers.isAddress(routerAddr)) {
                    resultEl.textContent = 'Please enter Router V5 address and click "Connect Router V5" first.';
                    resultEl.className = 'result error';
                    setButtonLoading(btn, false);
                    return;
                }

                let hasRouterRole = false;
                let isBridgeable = false;

                // Check ROUTER_ROLE on token
                try {
                    const token = new ethers.Contract(tokenAddr, TOKEN_ABI, provider || new ethers.JsonRpcProvider(document.getElementById('rpcUrl').value.trim()));
                    const routerRole = await token.ROUTER_ROLE();
                    hasRouterRole = await token.hasRole(routerRole, routerAddr);
                } catch (e) {
                    console.error('Error checking token role:', e);
                }

                // Check bridgeable status
                if (!routerV5) {
                    await connectToRouterV5(routerAddr);
                }
                if (routerV5) {
                    try {
                        isBridgeable = await routerV5.isBridgeableToken(tokenAddr);
                    } catch (e) {}
                }

                const routerRoleStatus = hasRouterRole ? ' Granted' : ' Not granted';
                const bridgeableStatus = isBridgeable ? ' Whitelisted' : ' Not whitelisted';
                const readyStatus = hasRouterRole && isBridgeable ? ' READY FOR BRIDGING' : ' NOT READY';

                resultEl.innerHTML = `
                    <strong>Token Bridge Status</strong><br><br>
                    Token: ${tokenAddr.slice(0,10)}...${tokenAddr.slice(-8)}<br>
                    Router: ${routerAddr ? routerAddr.slice(0,10) + '...' + routerAddr.slice(-8) : 'Not set'}<br><br>
                    ROUTER_ROLE: <span style="color: ${hasRouterRole ? '#22c55e' : '#ef4444'}">${routerRoleStatus}</span><br>
                    Whitelist: <span style="color: ${isBridgeable ? '#22c55e' : '#ef4444'}">${bridgeableStatus}</span><br><br>
                    <strong style="color: ${hasRouterRole && isBridgeable ? '#22c55e' : '#f59e0b'}">${readyStatus}</strong>
                `;
                resultEl.className = hasRouterRole && isBridgeable ? 'result success' : 'result';

            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function configureLastDeployedToken() {
            if (!lastDeployedToken || !lastDeployedToken.tokenAddress) {
                alert('No recently deployed token found');
                return;
            }

            // Switch to Router tab
            switchTab('router');

            // Set the token address in the configure input
            document.getElementById('configureTokenAddr').value = lastDeployedToken.tokenAddress;

            // Scroll to the Configure Token for Bridge card (first card with btn-success in Router tab)
            setTimeout(() => {
                const configureCard = document.querySelector('#router-tab .card:nth-child(3)');
                if (configureCard) {
                    configureCard.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    // Highlight the card briefly
                    configureCard.style.boxShadow = '0 0 0 3px #22c55e';
                    setTimeout(() => {
                        configureCard.style.boxShadow = '';
                    }, 2000);

                    // Auto-click the configure button
                    setTimeout(() => {
                        const btn = configureCard.querySelector('button.btn-success');
                        if (btn) btn.click();
                    }, 500);
                }
            }, 100);
        }

        // ==================== END ROUTER V5 FUNCTIONS ====================

        async function addImplementation(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');

            const newImpl = document.getElementById('newImpl').value.trim();
            const resultEl = document.getElementById('versionResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const tx = await factory.addImplementationVersion(newImpl);
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `Implementation added and set as default!`;
                resultEl.className = 'result success';
                await refreshInfo();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function setDefaultVersion(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');

            const version = parseInt(document.getElementById('defaultVersion').value);
            const resultEl = document.getElementById('versionResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const tx = await factory.setDefaultVersion(version);
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `Default version set to: ${version}`;
                resultEl.className = 'result success';
                await refreshInfo();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function grantRole(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');

            const roleName = document.getElementById('grantRoleSelect').value;
            const addr = document.getElementById('grantRoleAddr').value.trim();
            const resultEl = document.getElementById('roleResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const roleHash = await factory[roleName]();
                const tx = await factory.grantRole(roleHash, addr);
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `${roleName} granted to ${addr}`;
                resultEl.className = 'result success';
                await checkRoles();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function revokeRole(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');

            const roleName = document.getElementById('revokeRoleSelect').value;
            const addr = document.getElementById('revokeRoleAddr').value.trim();
            const resultEl = document.getElementById('roleResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const roleHash = await factory[roleName]();
                const tx = await factory.revokeRole(roleHash, addr);
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `${roleName} revoked from ${addr}`;
                resultEl.className = 'result success';
                await checkRoles();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function pauseFactory(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');
            const resultEl = document.getElementById('pauseResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const tx = await factory.pause();
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `Factory paused`;
                resultEl.className = 'result success';
                await refreshInfo();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function unpauseFactory(btn) {
            if (!factory || !signer) return alert('Please connect with a wallet first');
            const resultEl = document.getElementById('pauseResult');
            resultEl.classList.remove('hidden');
            setButtonLoading(btn, true);

            try {
                const tx = await factory.unpause();
                resultEl.textContent = `Transaction sent: ${tx.hash}`;
                await tx.wait();
                resultEl.textContent = `Factory unpaused`;
                resultEl.className = 'result success';
                await refreshInfo();
            } catch (error) {
                resultEl.textContent = `Error: ${error.reason || error.message}`;
                resultEl.className = 'result error';
            } finally {
                setButtonLoading(btn, false);
            }
        }

        async function switchToAmoy() {
            if (!window.ethereum) {
                alert('MetaMask not detected. Please install MetaMask.');
                return;
            }

            const amoyChainId = '0x13882'; // 80002 in hex

            try {
                // Try to switch to Amoy
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: amoyChainId }]
                });
                alert('Switched to Polygon Amoy! Click Connect now.');
            } catch (switchError) {
                // Network doesn't exist, add it
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: amoyChainId,
                                chainName: 'Polygon Amoy Testnet',
                                nativeCurrency: {
                                    name: 'POL',
                                    symbol: 'POL',
                                    decimals: 18
                                },
                                rpcUrls: ['https://polygon-amoy-bor-rpc.publicnode.com'],
                                blockExplorerUrls: ['https://amoy.polygonscan.com']
                            }]
                        });
                        alert('Polygon Amoy network added! Click Connect now.');
                    } catch (addError) {
                        alert('Failed to add network: ' + addError.message);
                    }
                } else {
                    alert('Failed to switch network: ' + switchError.message);
                }
            }
        }

        // Verification API URL
        const VERIFY_API_URL = 'https://reforge-v5-verification.vercel.app/api/verify';

        // Network chain ID to name mapping
        function getNetworkName(chainId) {
            const networkMap = {
                80002n: 'amoy',
                137n: 'polygon',
                1n: 'mainnet',
                11155111n: 'sepolia',
                8453n: 'base',
                84532n: 'baseSepolia',
                42161n: 'arbitrum',
                421614n: 'arbitrumSepolia',
                10n: 'optimism',
                56n: 'bsc',
                59144n: 'linea',
                534352n: 'scroll',
                81457n: 'blast',
                42220n: 'celo',
                100n: 'gnosis',
                250n: 'fantom',
                1284n: 'moonbeam',
                43114n: 'avalanche',
                5000n: 'mantle',
                324n: 'zksync'
            };
            return networkMap[chainId] || 'unknown';
        }

        // Explorer API URLs for checking verification status
        const EXPLORER_API_URLS = {
            'amoy': 'https://api-amoy.polygonscan.com/api',
            'polygon': 'https://api.polygonscan.com/api',
            'mainnet': 'https://api.etherscan.io/api',
            'sepolia': 'https://api-sepolia.etherscan.io/api',
            'base': 'https://api.basescan.org/api',
            'baseSepolia': 'https://api-sepolia.basescan.org/api',
            'arbitrum': 'https://api.arbiscan.io/api',
            'optimism': 'https://api-optimistic.etherscan.io/api',
            'bsc': 'https://api.bscscan.com/api'
        };

        // Check if a contract is verified on the block explorer
        async function isContractVerified(address, network) {
            const apiUrl = EXPLORER_API_URLS[network];
            if (!apiUrl) return null; // Unknown network, can't check

            try {
                const response = await fetch(`${apiUrl}?module=contract&action=getabi&address=${address}`);
                const data = await response.json();
                // If status is "1", the contract is verified (ABI is available)
                return data.status === '1';
            } catch (error) {
                console.error('Error checking verification status:', error);
                return null; // Error checking, show button anyway
            }
        }

        async function verifyDeployedToken() {
            if (!lastDeployedToken) {
                alert('No recently deployed token to verify');
                return;
            }

            const resultEl = document.getElementById('verifyResult');
            resultEl.classList.remove('hidden');
            resultEl.className = 'result';
            resultEl.textContent = `Verifying ${lastDeployedToken.symbol} on ${lastDeployedToken.network}...`;

            try {
                const response = await fetch(VERIFY_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(lastDeployedToken)
                });

                const result = await response.json();

                if (result.success) {
                    resultEl.innerHTML = ` ${result.message}<br><br>Token: ${lastDeployedToken.tokenAddress}<br>Network: ${lastDeployedToken.network}`;
                    resultEl.className = 'result success';
                } else {
                    resultEl.innerHTML = ` ${result.message}<br><br>Token: ${lastDeployedToken.tokenAddress}<br>Network: ${lastDeployedToken.network}`;
                    resultEl.className = 'result error';
                }
            } catch (error) {
                resultEl.textContent = `Error: ${error.message}`;
                resultEl.className = 'result error';
            }
        }

        // Modal functions
        function showModal(title, content, isSuccess) {
            document.getElementById('modalTitle').textContent = title;
            const bodyEl = document.getElementById('modalBody');
            bodyEl.innerHTML = content;
            bodyEl.className = 'modal-body ' + (isSuccess ? 'success' : 'error');
            document.getElementById('verifyModal').classList.remove('hidden');
        }

        function closeModal() {
            document.getElementById('verifyModal').classList.add('hidden');
        }

        async function verifyToken(tokenAddress, beaconAddress, name, symbol, decimals, network) {
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Verifying...';
            btn.disabled = true;

            let success = false;

            try {
                const response = await fetch(VERIFY_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        tokenAddress,
                        beaconAddress,
                        name,
                        symbol,
                        decimals,
                        network
                    })
                });

                const result = await response.json();

                if (result.success) {
                    success = true;
                    // Replace button with verified badge
                    const badge = document.createElement('span');
                    badge.style.cssText = 'margin-top: 8px; display: inline-block; padding: 6px 12px; font-size: 0.85em; background: #dcfce7; color: #16a34a; border-radius: 6px;';
                    badge.textContent = ' Verified';
                    btn.replaceWith(badge);

                    showModal('Verification Successful', `
                        <p><strong>Token:</strong> ${tokenAddress}</p>
                        <p><strong>Network:</strong> ${network}</p>
                        <p><strong>Message:</strong> ${result.message}</p>
                        ${result.guid ? `<p><strong>GUID:</strong> ${result.guid}</p>` : ''}
                    `, true);
                } else {
                    btn.textContent = ' Failed';
                    btn.style.background = '#ef4444';
                    showModal('Verification Failed', `
                        <p><strong>Token:</strong> ${tokenAddress}</p>
                        <p><strong>Network:</strong> ${network}</p>
                        <p><strong>Error:</strong></p>
                        <pre>${result.message || result.error || JSON.stringify(result, null, 2)}</pre>
                    `, false);
                }
            } catch (error) {
                btn.textContent = ' Error';
                btn.style.background = '#ef4444';
                showModal('Verification Error', `
                    <p><strong>Error:</strong></p>
                    <pre>${error.message}</pre>
                `, false);
            }

            // Only reset button if verification failed
            if (!success) {
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                    btn.disabled = false;
                }, 3000);
            }
        }

        window.addEventListener('load', async () => {
            if (window.ethereum) {
                document.getElementById('rpcUrl').placeholder = 'MetaMask detected - will use wallet';
                // Auto-connect wallet if already authorized
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        // Wallet already connected, auto-connect wallet only
                        await connectWallet();
                    }
                } catch (e) {
                    console.log('Auto-connect check failed:', e);
                }
            }
        });

        // Listen for account/network changes
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', () => {
                window.location.reload();
            });
            window.ethereum.on('chainChanged', () => {
                window.location.reload();
            });
        }
    </script>
</body>
</html>
